// Code generated by "goki generate ./..."; DO NOT EDIT.

package prjn

import (
	"goki.dev/gti"
	"goki.dev/ordmap"
)

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/prjn.Circle",
	ShortName:  "prjn.Circle",
	IDName:     "circle",
	Doc:        "Circle implements a circular pattern of connectivity between two layers\nwhere the center moves in proportion to receiver position with offset\nand multiplier factors, and a given radius is used (with wrap-around\noptionally).  A corresponding Gaussian bump of TopoWts is available as well.\nMakes for a good center-surround connectivity pattern.\n4D layers are automatically flattened to 2D for this connection.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Radius", &gti.Field{Name: "Radius", Type: "int", LocalType: "int", Doc: "radius of the circle, in units from center in sending layer", Directives: gti.Directives{}, Tag: ""}},
		{"Start", &gti.Field{Name: "Start", Type: "github.com/emer/emergent/v2/evec.Vec2i", LocalType: "evec.Vec2i", Doc: "starting offset in sending layer, for computing the corresponding sending center relative to given recv unit position", Directives: gti.Directives{}, Tag: ""}},
		{"Scale", &gti.Field{Name: "Scale", Type: "goki.dev/mat32.Vec2", LocalType: "mat32.Vec2", Doc: "scaling to apply to receiving unit position to compute sending center as function of recv unit position", Directives: gti.Directives{}, Tag: ""}},
		{"AutoScale", &gti.Field{Name: "AutoScale", Type: "bool", LocalType: "bool", Doc: "auto-scale sending center positions as function of relative sizes of send and recv layers -- if Start is positive then assumes it is a border, subtracted from sending size", Directives: gti.Directives{}, Tag: ""}},
		{"Wrap", &gti.Field{Name: "Wrap", Type: "bool", LocalType: "bool", Doc: "if true, connectivity wraps around edges", Directives: gti.Directives{}, Tag: ""}},
		{"TopoWts", &gti.Field{Name: "TopoWts", Type: "bool", LocalType: "bool", Doc: "if true, this prjn should set gaussian topographic weights, according to following parameters", Directives: gti.Directives{}, Tag: ""}},
		{"Sigma", &gti.Field{Name: "Sigma", Type: "float32", LocalType: "float32", Doc: "gaussian sigma (width) as a proportion of the radius of the circle", Directives: gti.Directives{}, Tag: ""}},
		{"MaxWt", &gti.Field{Name: "MaxWt", Type: "float32", LocalType: "float32", Doc: "maximum weight value for GaussWts function -- multiplies values", Directives: gti.Directives{}, Tag: ""}},
		{"SelfCon", &gti.Field{Name: "SelfCon", Type: "bool", LocalType: "bool", Doc: "if true, and connecting layer to itself (self projection), then make a self-connection from unit to itself", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/prjn.Full",
	ShortName:  "prjn.Full",
	IDName:     "full",
	Doc:        "Full implements full all-to-all pattern of connectivity between two layers",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SelfCon", &gti.Field{Name: "SelfCon", Type: "bool", LocalType: "bool", Doc: "if true, and connecting layer to itself (self projection), then make a self-connection from unit to itself", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/prjn.OneToOne",
	ShortName:  "prjn.OneToOne",
	IDName:     "one-to-one",
	Doc:        "OneToOne implements point-to-point one-to-one pattern of connectivity between two layers",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NCons", &gti.Field{Name: "NCons", Type: "int", LocalType: "int", Doc: "number of recv connections to make (0 for entire size of recv layer)", Directives: gti.Directives{}, Tag: ""}},
		{"SendStart", &gti.Field{Name: "SendStart", Type: "int", LocalType: "int", Doc: "starting unit index for sending connections", Directives: gti.Directives{}, Tag: ""}},
		{"RecvStart", &gti.Field{Name: "RecvStart", Type: "int", LocalType: "int", Doc: "starting unit index for recv connections", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/prjn.Pattern",
	ShortName:  "prjn.Pattern",
	IDName:     "pattern",
	Doc:        "Pattern defines a pattern of connectivity between two layers.\nThe pattern is stored efficiently using a bitslice tensor of binary values indicating\npresence or absence of connection between two items.\nA receiver-based organization is generally assumed but connectivity can go either way.",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/prjn.PoolOneToOne",
	ShortName:  "prjn.PoolOneToOne",
	IDName:     "pool-one-to-one",
	Doc:        "PoolOneToOne implements one-to-one connectivity between pools within layers.\nPools are the outer-most two dimensions of a 4D layer shape.\nIf either layer does not have pools, then if the number of individual\nunits matches the number of pools in the other layer, those are connected one-to-one\notherwise each pool connects to the entire set of other units.\nIf neither is 4D, then it is equivalent to OneToOne.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NPools", &gti.Field{Name: "NPools", Type: "int", LocalType: "int", Doc: "number of recv pools to connect (0 for entire number of pools in recv layer)", Directives: gti.Directives{}, Tag: ""}},
		{"SendStart", &gti.Field{Name: "SendStart", Type: "int", LocalType: "int", Doc: "starting pool index for sending connections", Directives: gti.Directives{}, Tag: ""}},
		{"RecvStart", &gti.Field{Name: "RecvStart", Type: "int", LocalType: "int", Doc: "starting pool index for recv connections", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/prjn.PoolRect",
	ShortName:  "prjn.PoolRect",
	IDName:     "pool-rect",
	Doc:        "PoolRect implements a rectangular pattern of connectivity between\ntwo 4D layers, in terms of their pool-level shapes,\nwhere the lower-left corner moves in proportion to receiver\npool position with offset and multiplier factors (with wrap-around optionally).",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Size", &gti.Field{Name: "Size", Type: "github.com/emer/emergent/v2/evec.Vec2i", LocalType: "evec.Vec2i", Doc: "size of rectangle (of pools) in sending layer that each receiving unit receives from", Directives: gti.Directives{}, Tag: ""}},
		{"Start", &gti.Field{Name: "Start", Type: "github.com/emer/emergent/v2/evec.Vec2i", LocalType: "evec.Vec2i", Doc: "starting pool offset in sending layer, for computing the corresponding sending lower-left corner relative to given recv pool position", Directives: gti.Directives{}, Tag: ""}},
		{"Scale", &gti.Field{Name: "Scale", Type: "goki.dev/mat32.Vec2", LocalType: "mat32.Vec2", Doc: "scaling to apply to receiving pool osition to compute corresponding position in sending layer of the lower-left corner of rectangle", Directives: gti.Directives{}, Tag: ""}},
		{"AutoScale", &gti.Field{Name: "AutoScale", Type: "bool", LocalType: "bool", Doc: "auto-set the Scale as function of the relative pool sizes of send and recv layers (e.g., if sending layer is 2x larger than receiving, Scale = 2)", Directives: gti.Directives{}, Tag: ""}},
		{"RoundScale", &gti.Field{Name: "RoundScale", Type: "bool", LocalType: "bool", Doc: "if true, use Round when applying scaling factor -- otherwise uses Floor which makes Scale work like a grouping factor -- e.g., .25 will effectively group 4 recv pools with same send position", Directives: gti.Directives{}, Tag: ""}},
		{"Wrap", &gti.Field{Name: "Wrap", Type: "bool", LocalType: "bool", Doc: "if true, connectivity wraps around all edges if it would otherwise go off the edge -- if false, then edges are clipped", Directives: gti.Directives{}, Tag: ""}},
		{"SelfCon", &gti.Field{Name: "SelfCon", Type: "bool", LocalType: "bool", Doc: "if true, and connecting layer to itself (self projection), then make a self-connection from unit to itself", Directives: gti.Directives{}, Tag: ""}},
		{"RecvStart", &gti.Field{Name: "RecvStart", Type: "github.com/emer/emergent/v2/evec.Vec2i", LocalType: "evec.Vec2i", Doc: "starting pool position in receiving layer -- if > 0 then pools below this starting point remain unconnected", Directives: gti.Directives{}, Tag: ""}},
		{"RecvN", &gti.Field{Name: "RecvN", Type: "github.com/emer/emergent/v2/evec.Vec2i", LocalType: "evec.Vec2i", Doc: "number of pools in receiving layer to connect -- if 0 then all (remaining after RecvStart) are connected -- otherwise if < remaining then those beyond this point remain unconnected", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/prjn.PoolSameUnit",
	ShortName:  "prjn.PoolSameUnit",
	IDName:     "pool-same-unit",
	Doc:        "PoolSameUnit connects a given unit to the unit at the same index\nacross all the pools in a layer.\nPools are the outer-most two dimensions of a 4D layer shape.\nThis is most sensible when pools have same numbers of units in send and recv.\nThis is typically used for lateral topography-inducing connectivity\nand can also serve to reduce a pooled layer down to a single pool.\nThe logic works if either layer does not have pools.\nIf neither is 4D, then it is equivalent to OneToOne.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"SelfCon", &gti.Field{Name: "SelfCon", Type: "bool", LocalType: "bool", Doc: "if true, and connecting layer to itself (self projection), then make a self-connection from unit to itself", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/prjn.PoolTile",
	ShortName:  "prjn.PoolTile",
	IDName:     "pool-tile",
	Doc:        "PoolTile implements tiled 2D connectivity between pools within layers, where\na 2D rectangular receptive field (defined over pools, not units) is tiled\nacross the sending layer pools, with specified level of overlap.\nPools are the outer-most two dimensions of a 4D layer shape.\n2D layers are assumed to have 1x1 pool.\nThis is a standard form of convolutional connectivity, where pools are\nthe filters and the outer dims are locations filtered.\nVarious initial weight / scaling patterns are also available -- code\nmust specifically apply these to the receptive fields.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Recip", &gti.Field{Name: "Recip", Type: "bool", LocalType: "bool", Doc: "reciprocal topographic connectivity -- logic runs with recv <-> send -- produces symmetric back-projection or topo prjn when sending layer is larger than recv", Directives: gti.Directives{}, Tag: ""}},
		{"Size", &gti.Field{Name: "Size", Type: "github.com/emer/emergent/v2/evec.Vec2i", LocalType: "evec.Vec2i", Doc: "size of receptive field tile, in terms of pools on the sending layer", Directives: gti.Directives{}, Tag: ""}},
		{"Skip", &gti.Field{Name: "Skip", Type: "github.com/emer/emergent/v2/evec.Vec2i", LocalType: "evec.Vec2i", Doc: "how many pools to skip in tiling over sending layer -- typically 1/2 of Size", Directives: gti.Directives{}, Tag: ""}},
		{"Start", &gti.Field{Name: "Start", Type: "github.com/emer/emergent/v2/evec.Vec2i", LocalType: "evec.Vec2i", Doc: "starting pool offset for lower-left corner of first receptive field in sending layer", Directives: gti.Directives{}, Tag: ""}},
		{"Wrap", &gti.Field{Name: "Wrap", Type: "bool", LocalType: "bool", Doc: "if true, pool coordinates wrap around sending shape -- otherwise truncated at edges, which can lead to assymmetries in connectivity etc", Directives: gti.Directives{}, Tag: ""}},
		{"GaussFull", &gti.Field{Name: "GaussFull", Type: "github.com/emer/emergent/v2/prjn.GaussTopo", LocalType: "GaussTopo", Doc: "gaussian topographic weights / scaling parameters for full receptive field width. multiplies any other factors present", Directives: gti.Directives{}, Tag: ""}},
		{"GaussInPool", &gti.Field{Name: "GaussInPool", Type: "github.com/emer/emergent/v2/prjn.GaussTopo", LocalType: "GaussTopo", Doc: "gaussian topographic weights / scaling parameters within individual sending pools (i.e., unit positions within their parent pool drive distance for gaussian) -- this helps organize / differentiate units more within pools, not just across entire receptive field. multiplies any other factors present", Directives: gti.Directives{}, Tag: ""}},
		{"SigFull", &gti.Field{Name: "SigFull", Type: "github.com/emer/emergent/v2/prjn.SigmoidTopo", LocalType: "SigmoidTopo", Doc: "sigmoidal topographic weights / scaling parameters for full receptive field width.  left / bottom half have increasing sigmoids, and second half decrease.  Multiplies any other factors present (only used if Gauss versions are not On!)", Directives: gti.Directives{}, Tag: ""}},
		{"SigInPool", &gti.Field{Name: "SigInPool", Type: "github.com/emer/emergent/v2/prjn.SigmoidTopo", LocalType: "SigmoidTopo", Doc: "sigmoidal topographic weights / scaling parameters within individual sending pools (i.e., unit positions within their parent pool drive distance for sigmoid) -- this helps organize / differentiate units more within pools, not just across entire receptive field. multiplies any other factors present  (only used if Gauss versions are not On!).  left / bottom half have increasing sigmoids, and second half decrease.", Directives: gti.Directives{}, Tag: ""}},
		{"TopoRange", &gti.Field{Name: "TopoRange", Type: "github.com/emer/etable/v2/minmax.F32", LocalType: "minmax.F32", Doc: "min..max range of topographic weight values to generate", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/prjn.GaussTopo",
	ShortName:  "prjn.GaussTopo",
	IDName:     "gauss-topo",
	Doc:        "GaussTopo has parameters for Gaussian topographic weights or scaling factors",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"On", &gti.Field{Name: "On", Type: "bool", LocalType: "bool", Doc: "use gaussian topographic weights / scaling values", Directives: gti.Directives{}, Tag: ""}},
		{"Sigma", &gti.Field{Name: "Sigma", Type: "float32", LocalType: "float32", Doc: "gaussian sigma (width) in normalized units where entire distance across relevant dimension is 1.0 -- typical useful values range from .3 to 1.5, with .6 default", Directives: gti.Directives{}, Tag: "viewif:\"On\" def:\"0.6\""}},
		{"Wrap", &gti.Field{Name: "Wrap", Type: "bool", LocalType: "bool", Doc: "wrap the gaussian around on other sides of the receptive field, with the closest distance being used -- this removes strict topography but ensures a more uniform distribution of weight values so edge units don't have weaker overall weights", Directives: gti.Directives{}, Tag: "viewif:\"On\""}},
		{"CtrMove", &gti.Field{Name: "CtrMove", Type: "float32", LocalType: "float32", Doc: "proportion to move gaussian center relative to the position of the receiving unit within its pool: 1.0 = centers span the entire range of the receptive field.  Typically want to use 1.0 for Wrap = true, and 0.8 for false", Directives: gti.Directives{}, Tag: "viewif:\"On\" def:\"0.8,1\""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/prjn.SigmoidTopo",
	ShortName:  "prjn.SigmoidTopo",
	IDName:     "sigmoid-topo",
	Doc:        "SigmoidTopo has parameters for Gaussian topographic weights or scaling factors",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"On", &gti.Field{Name: "On", Type: "bool", LocalType: "bool", Doc: "use gaussian topographic weights / scaling values", Directives: gti.Directives{}, Tag: ""}},
		{"Gain", &gti.Field{Name: "Gain", Type: "float32", LocalType: "float32", Doc: "gain of sigmoid that determines steepness of curve, in normalized units where entire distance across relevant dimension is 1.0 -- typical useful values range from 0.01 to 0.1", Directives: gti.Directives{}, Tag: "viewif:\"On\""}},
		{"CtrMove", &gti.Field{Name: "CtrMove", Type: "float32", LocalType: "float32", Doc: "proportion to move gaussian center relative to the position of the receiving unit within its pool: 1.0 = centers span the entire range of the receptive field.  Typically want to use 1.0 for Wrap = true, and 0.8 for false", Directives: gti.Directives{}, Tag: "viewif:\"On\" def:\"0.5,1\""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/prjn.PoolTileSub",
	ShortName:  "prjn.PoolTileSub",
	IDName:     "pool-tile-sub",
	Doc:        "PoolTileSub implements tiled 2D connectivity between pools within layers, where\na 2D rectangular receptive field (defined over pools, not units) is tiled\nacross the sending layer pools, with specified level of overlap.\nPools are the outer-most two dimensions of a 4D layer shape.\nSub version has sub-pools within each pool to encourage more independent\nrepresentations.\n2D layers are assumed to have 1x1 pool.\nThis is a standard form of convolutional connectivity, where pools are\nthe filters and the outer dims are locations filtered.\nVarious initial weight / scaling patterns are also available -- code\nmust specifically apply these to the receptive fields.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Recip", &gti.Field{Name: "Recip", Type: "bool", LocalType: "bool", Doc: "reciprocal topographic connectivity -- logic runs with recv <-> send -- produces symmetric back-projection or topo prjn when sending layer is larger than recv", Directives: gti.Directives{}, Tag: ""}},
		{"Size", &gti.Field{Name: "Size", Type: "github.com/emer/emergent/v2/evec.Vec2i", LocalType: "evec.Vec2i", Doc: "size of receptive field tile, in terms of pools on the sending layer", Directives: gti.Directives{}, Tag: ""}},
		{"Skip", &gti.Field{Name: "Skip", Type: "github.com/emer/emergent/v2/evec.Vec2i", LocalType: "evec.Vec2i", Doc: "how many pools to skip in tiling over sending layer -- typically 1/2 of Size", Directives: gti.Directives{}, Tag: ""}},
		{"Start", &gti.Field{Name: "Start", Type: "github.com/emer/emergent/v2/evec.Vec2i", LocalType: "evec.Vec2i", Doc: "starting pool offset for lower-left corner of first receptive field in sending layer", Directives: gti.Directives{}, Tag: ""}},
		{"Subs", &gti.Field{Name: "Subs", Type: "github.com/emer/emergent/v2/evec.Vec2i", LocalType: "evec.Vec2i", Doc: "number of sub-pools within each pool", Directives: gti.Directives{}, Tag: ""}},
		{"SendSubs", &gti.Field{Name: "SendSubs", Type: "bool", LocalType: "bool", Doc: "sending layer has sub-pools", Directives: gti.Directives{}, Tag: ""}},
		{"Wrap", &gti.Field{Name: "Wrap", Type: "bool", LocalType: "bool", Doc: "if true, pool coordinates wrap around sending shape -- otherwise truncated at edges, which can lead to assymmetries in connectivity etc", Directives: gti.Directives{}, Tag: ""}},
		{"GaussFull", &gti.Field{Name: "GaussFull", Type: "github.com/emer/emergent/v2/prjn.GaussTopo", LocalType: "GaussTopo", Doc: "gaussian topographic weights / scaling parameters for full receptive field width. multiplies any other factors present", Directives: gti.Directives{}, Tag: ""}},
		{"GaussInPool", &gti.Field{Name: "GaussInPool", Type: "github.com/emer/emergent/v2/prjn.GaussTopo", LocalType: "GaussTopo", Doc: "gaussian topographic weights / scaling parameters within individual sending pools (i.e., unit positions within their parent pool drive distance for gaussian) -- this helps organize / differentiate units more within pools, not just across entire receptive field. multiplies any other factors present", Directives: gti.Directives{}, Tag: ""}},
		{"SigFull", &gti.Field{Name: "SigFull", Type: "github.com/emer/emergent/v2/prjn.SigmoidTopo", LocalType: "SigmoidTopo", Doc: "sigmoidal topographic weights / scaling parameters for full receptive field width.  left / bottom half have increasing sigmoids, and second half decrease.  Multiplies any other factors present (only used if Gauss versions are not On!)", Directives: gti.Directives{}, Tag: ""}},
		{"SigInPool", &gti.Field{Name: "SigInPool", Type: "github.com/emer/emergent/v2/prjn.SigmoidTopo", LocalType: "SigmoidTopo", Doc: "sigmoidal topographic weights / scaling parameters within individual sending pools (i.e., unit positions within their parent pool drive distance for sigmoid) -- this helps organize / differentiate units more within pools, not just across entire receptive field. multiplies any other factors present  (only used if Gauss versions are not On!).  left / bottom half have increasing sigmoids, and second half decrease.", Directives: gti.Directives{}, Tag: ""}},
		{"TopoRange", &gti.Field{Name: "TopoRange", Type: "github.com/emer/etable/v2/minmax.F32", LocalType: "minmax.F32", Doc: "min..max range of topographic weight values to generate", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/prjn.PoolUnifRnd",
	ShortName:  "prjn.PoolUnifRnd",
	IDName:     "pool-unif-rnd",
	Doc:        "PoolUnifRnd implements random pattern of connectivity between pools within layers.\nPools are the outer-most two dimensions of a 4D layer shape.\nIf either layer does not have pools, PoolUnifRnd works as UnifRnd does.\nIf probability of connection (PCon) is 1, PoolUnifRnd works as PoolOnetoOne does.",
	Directives: gti.Directives{},
	Fields:     ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"PoolOneToOne", &gti.Field{Name: "PoolOneToOne", Type: "github.com/emer/emergent/v2/prjn.PoolOneToOne", LocalType: "PoolOneToOne", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		{"UnifRnd", &gti.Field{Name: "UnifRnd", Type: "github.com/emer/emergent/v2/prjn.UnifRnd", LocalType: "UnifRnd", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/prjn.Rect",
	ShortName:  "prjn.Rect",
	IDName:     "rect",
	Doc:        "Rect implements a rectangular pattern of connectivity between two layers\nwhere the lower-left corner moves in proportion to receiver position with offset\nand multiplier factors (with wrap-around optionally).\n4D layers are automatically flattened to 2D for this projection.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Size", &gti.Field{Name: "Size", Type: "github.com/emer/emergent/v2/evec.Vec2i", LocalType: "evec.Vec2i", Doc: "size of rectangle in sending layer that each receiving unit receives from", Directives: gti.Directives{}, Tag: ""}},
		{"Start", &gti.Field{Name: "Start", Type: "github.com/emer/emergent/v2/evec.Vec2i", LocalType: "evec.Vec2i", Doc: "starting offset in sending layer, for computing the corresponding sending lower-left corner relative to given recv unit position", Directives: gti.Directives{}, Tag: ""}},
		{"Scale", &gti.Field{Name: "Scale", Type: "goki.dev/mat32.Vec2", LocalType: "mat32.Vec2", Doc: "scaling to apply to receiving unit position to compute corresponding position in sending layer of the lower-left corner of rectangle", Directives: gti.Directives{}, Tag: ""}},
		{"AutoScale", &gti.Field{Name: "AutoScale", Type: "bool", LocalType: "bool", Doc: "auto-set the Scale as function of the relative sizes of send and recv layers (e.g., if sending layer is 2x larger than receiving, Scale = 2)", Directives: gti.Directives{}, Tag: ""}},
		{"RoundScale", &gti.Field{Name: "RoundScale", Type: "bool", LocalType: "bool", Doc: "if true, use Round when applying scaling factor -- otherwise uses Floor which makes Scale work like a grouping factor -- e.g., .25 will effectively group 4 recv units with same send position", Directives: gti.Directives{}, Tag: ""}},
		{"Wrap", &gti.Field{Name: "Wrap", Type: "bool", LocalType: "bool", Doc: "if true, connectivity wraps around all edges if it would otherwise go off the edge -- if false, then edges are clipped", Directives: gti.Directives{}, Tag: ""}},
		{"SelfCon", &gti.Field{Name: "SelfCon", Type: "bool", LocalType: "bool", Doc: "if true, and connecting layer to itself (self projection), then make a self-connection from unit to itself", Directives: gti.Directives{}, Tag: ""}},
		{"Recip", &gti.Field{Name: "Recip", Type: "bool", LocalType: "bool", Doc: "make the reciprocal of the specified connections -- i.e., symmetric for swapping recv and send", Directives: gti.Directives{}, Tag: ""}},
		{"RecvStart", &gti.Field{Name: "RecvStart", Type: "github.com/emer/emergent/v2/evec.Vec2i", LocalType: "evec.Vec2i", Doc: "starting position in receiving layer -- if > 0 then units below this starting point remain unconnected", Directives: gti.Directives{}, Tag: ""}},
		{"RecvN", &gti.Field{Name: "RecvN", Type: "github.com/emer/emergent/v2/evec.Vec2i", LocalType: "evec.Vec2i", Doc: "number of units in receiving layer to connect -- if 0 then all (remaining after RecvStart) are connected -- otherwise if < remaining then those beyond this point remain unconnected", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/prjn.UnifRnd",
	ShortName:  "prjn.UnifRnd",
	IDName:     "unif-rnd",
	Doc:        "UnifRnd implements uniform random pattern of connectivity between two layers\nusing a permuted (shuffled) list for without-replacement randomness,\nand maintains its own local random number source and seed\nwhich are initialized if Rand == nil -- usually best to keep this\nspecific to each instance of a projection so it is fully reproducible\nand doesn't interfere with other random number streams.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"PCon", &gti.Field{Name: "PCon", Type: "float32", LocalType: "float32", Doc: "probability of connection (0-1)", Directives: gti.Directives{}, Tag: "min:\"0\" max:\"1\""}},
		{"SelfCon", &gti.Field{Name: "SelfCon", Type: "bool", LocalType: "bool", Doc: "if true, and connecting layer to itself (self projection), then make a self-connection from unit to itself", Directives: gti.Directives{}, Tag: ""}},
		{"Recip", &gti.Field{Name: "Recip", Type: "bool", LocalType: "bool", Doc: "reciprocal connectivity: if true, switch the sending and receiving layers to create a symmetric top-down projection -- ESSENTIAL to use same RndSeed between two prjns to ensure symmetry", Directives: gti.Directives{}, Tag: ""}},
		{"Rand", &gti.Field{Name: "Rand", Type: "github.com/emer/emergent/v2/erand.Rand", LocalType: "erand.Rand", Doc: "random number source -- is created with its own separate source if nil", Directives: gti.Directives{}, Tag: "view:\"-\""}},
		{"RndSeed", &gti.Field{Name: "RndSeed", Type: "int64", LocalType: "int64", Doc: "the current random seed -- will be initialized to a new random number from the global random stream when Rand is created.", Directives: gti.Directives{}, Tag: "view:\"-\""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

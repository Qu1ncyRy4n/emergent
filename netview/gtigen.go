// Code generated by "goki generate"; DO NOT EDIT.

package netview

import (
	"sync"

	"goki.dev/colors/colormap"
	"goki.dev/gi/v2/gi"
	"goki.dev/goosi/events"
	"goki.dev/gti"
	"goki.dev/ki/v2"
	"goki.dev/ordmap"
	"goki.dev/xyz"
)

// LayNameType is the [gti.Type] for [LayName]
var LayNameType = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/netview.LayName",
	ShortName:  "netview.LayName",
	IDName:     "lay-name",
	Doc:        "LayName is the Layer name as a Text2D within the NetView",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"NetView", &gti.Field{Name: "NetView", Type: "*github.com/emer/emergent/v2/netview.NetView", LocalType: "*NetView", Doc: "our netview", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" view:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Text2D", &gti.Field{Name: "Text2D", Type: "goki.dev/xyz.Text2D", LocalType: "xyz.Text2D", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &LayName{},
})

// NewLayName adds a new [LayName] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewLayName(par ki.Ki, name ...string) *LayName {
	return par.NewChild(LayNameType, name...).(*LayName)
}

// KiType returns the [*gti.Type] of [LayName]
func (t *LayName) KiType() *gti.Type {
	return LayNameType
}

// New returns a new [*LayName] value
func (t *LayName) New() ki.Ki {
	return &LayName{}
}

// SetNetView sets the [LayName.NetView]:
// our netview
func (t *LayName) SetNetView(v *NetView) *LayName {
	t.NetView = v
	return t
}

// SetMat sets the [LayName.Mat]
func (t *LayName) SetMat(v xyz.Material) *LayName {
	t.Mat = v
	return t
}

// SetText sets the [LayName.Text]
func (t *LayName) SetText(v string) *LayName {
	t.Text = v
	return t
}

// LayObjType is the [gti.Type] for [LayObj]
var LayObjType = gti.AddType(&gti.Type{
	Name:      "github.com/emer/emergent/v2/netview.LayObj",
	ShortName: "netview.LayObj",
	IDName:    "lay-obj",
	Doc:       "LayObj is the Layer 3D object within the NetView",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"LayName", &gti.Field{Name: "LayName", Type: "string", LocalType: "string", Doc: "name of the layer we represent", Directives: gti.Directives{}, Tag: ""}},
		{"NetView", &gti.Field{Name: "NetView", Type: "*github.com/emer/emergent/v2/netview.NetView", LocalType: "*NetView", Doc: "our netview", Directives: gti.Directives{}, Tag: "copy:\"-\" json:\"-\" xml:\"-\" view:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Solid", &gti.Field{Name: "Solid", Type: "goki.dev/xyz.Solid", LocalType: "xyz.Solid", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods:  ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
	Instance: &LayObj{},
})

// NewLayObj adds a new [LayObj] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewLayObj(par ki.Ki, name ...string) *LayObj {
	return par.NewChild(LayObjType, name...).(*LayObj)
}

// KiType returns the [*gti.Type] of [LayObj]
func (t *LayObj) KiType() *gti.Type {
	return LayObjType
}

// New returns a new [*LayObj] value
func (t *LayObj) New() ki.Ki {
	return &LayObj{}
}

// SetLayName sets the [LayObj.LayName]:
// name of the layer we represent
func (t *LayObj) SetLayName(v string) *LayObj {
	t.LayName = v
	return t
}

// SetNetView sets the [LayObj.NetView]:
// our netview
func (t *LayObj) SetNetView(v *NetView) *LayObj {
	t.NetView = v
	return t
}

// SetMat sets the [LayObj.Mat]
func (t *LayObj) SetMat(v xyz.Material) *LayObj {
	t.Mat = v
	return t
}

// NetViewType is the [gti.Type] for [NetView]
var NetViewType = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/netview.NetView",
	ShortName:  "netview.NetView",
	IDName:     "net-view",
	Doc:        "NetView is a GoGi Widget that provides a 3D network view using the GoGi gi3d\n3D framework.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Net", &gti.Field{Name: "Net", Type: "github.com/emer/emergent/v2/emer.Network", LocalType: "emer.Network", Doc: "the network that we're viewing", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Var", &gti.Field{Name: "Var", Type: "string", LocalType: "string", Doc: "current variable that we're viewing", Directives: gti.Directives{}, Tag: "set:\"-\""}},
		{"Di", &gti.Field{Name: "Di", Type: "int", LocalType: "int", Doc: "current data parallel index di, for networks capable of processing input patterns in parallel.", Directives: gti.Directives{}, Tag: ""}},
		{"Vars", &gti.Field{Name: "Vars", Type: "[]string", LocalType: "[]string", Doc: "the list of variables to view", Directives: gti.Directives{}, Tag: ""}},
		{"SynVars", &gti.Field{Name: "SynVars", Type: "[]string", LocalType: "[]string", Doc: "list of synaptic variables", Directives: gti.Directives{}, Tag: ""}},
		{"SynVarsMap", &gti.Field{Name: "SynVarsMap", Type: "map[string]int", LocalType: "map[string]int", Doc: "map of synaptic variable names to index", Directives: gti.Directives{}, Tag: ""}},
		{"VarParams", &gti.Field{Name: "VarParams", Type: "map[string]*github.com/emer/emergent/v2/netview.VarParams", LocalType: "map[string]*VarParams", Doc: "parameters for the list of variables to view", Directives: gti.Directives{}, Tag: ""}},
		{"CurVarParams", &gti.Field{Name: "CurVarParams", Type: "*github.com/emer/emergent/v2/netview.VarParams", LocalType: "*VarParams", Doc: "current var params -- only valid during Update of display", Directives: gti.Directives{}, Tag: "json:\"-\" xml:\"-\" view:\"-\""}},
		{"Params", &gti.Field{Name: "Params", Type: "github.com/emer/emergent/v2/netview.Params", LocalType: "Params", Doc: "parameters controlling how the view is rendered", Directives: gti.Directives{}, Tag: ""}},
		{"ColorMap", &gti.Field{Name: "ColorMap", Type: "*goki.dev/colors/colormap.Map", LocalType: "*colormap.Map", Doc: "color map for mapping values to colors -- set by name in Params", Directives: gti.Directives{}, Tag: ""}},
		{"RecNo", &gti.Field{Name: "RecNo", Type: "int", LocalType: "int", Doc: "record number to display -- use -1 to always track latest, otherwise in range", Directives: gti.Directives{}, Tag: ""}},
		{"LastCtrs", &gti.Field{Name: "LastCtrs", Type: "string", LocalType: "string", Doc: "last non-empty counters string provided -- re-used if no new one", Directives: gti.Directives{}, Tag: ""}},
		{"Data", &gti.Field{Name: "Data", Type: "github.com/emer/emergent/v2/netview.NetData", LocalType: "NetData", Doc: "contains all the network data with history", Directives: gti.Directives{}, Tag: ""}},
		{"DataMu", &gti.Field{Name: "DataMu", Type: "sync.RWMutex", LocalType: "sync.RWMutex", Doc: "mutex on data access", Directives: gti.Directives{}, Tag: "view:\"-\" copy:\"-\" json:\"-\" xml:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Layout", &gti.Field{Name: "Layout", Type: "goki.dev/gi/v2/gi.Layout", LocalType: "gi.Layout", Doc: "", Directives: gti.Directives{}, Tag: ""}},
	}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{
		{"Current", &gti.Method{Name: "Current", Doc: "Current records the current state of the network, including synaptic values,\nand updates the display.  Use this when switching to NetView tab after network\nhas been running while viewing another tab, because the network state\nis typically not recored then.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
	}),
	Instance: &NetView{},
})

// NewNetView adds a new [NetView] with the given name
// to the given parent. If the name is unspecified, it defaults
// to the ID (kebab-case) name of the type, plus the
// [ki.Ki.NumLifetimeChildren] of the given parent.
func NewNetView(par ki.Ki, name ...string) *NetView {
	return par.NewChild(NetViewType, name...).(*NetView)
}

// KiType returns the [*gti.Type] of [NetView]
func (t *NetView) KiType() *gti.Type {
	return NetViewType
}

// New returns a new [*NetView] value
func (t *NetView) New() ki.Ki {
	return &NetView{}
}

// SetDi sets the [NetView.Di]:
// current data parallel index di, for networks capable of processing input patterns in parallel.
func (t *NetView) SetDi(v int) *NetView {
	t.Di = v
	return t
}

// SetVars sets the [NetView.Vars]:
// the list of variables to view
func (t *NetView) SetVars(v []string) *NetView {
	t.Vars = v
	return t
}

// SetSynVars sets the [NetView.SynVars]:
// list of synaptic variables
func (t *NetView) SetSynVars(v []string) *NetView {
	t.SynVars = v
	return t
}

// SetSynVarsMap sets the [NetView.SynVarsMap]:
// map of synaptic variable names to index
func (t *NetView) SetSynVarsMap(v map[string]int) *NetView {
	t.SynVarsMap = v
	return t
}

// SetVarParams sets the [NetView.VarParams]:
// parameters for the list of variables to view
func (t *NetView) SetVarParams(v map[string]*VarParams) *NetView {
	t.VarParams = v
	return t
}

// SetCurVarParams sets the [NetView.CurVarParams]:
// current var params -- only valid during Update of display
func (t *NetView) SetCurVarParams(v *VarParams) *NetView {
	t.CurVarParams = v
	return t
}

// SetParams sets the [NetView.Params]:
// parameters controlling how the view is rendered
func (t *NetView) SetParams(v Params) *NetView {
	t.Params = v
	return t
}

// SetColorMap sets the [NetView.ColorMap]:
// color map for mapping values to colors -- set by name in Params
func (t *NetView) SetColorMap(v *colormap.Map) *NetView {
	t.ColorMap = v
	return t
}

// SetRecNo sets the [NetView.RecNo]:
// record number to display -- use -1 to always track latest, otherwise in range
func (t *NetView) SetRecNo(v int) *NetView {
	t.RecNo = v
	return t
}

// SetLastCtrs sets the [NetView.LastCtrs]:
// last non-empty counters string provided -- re-used if no new one
func (t *NetView) SetLastCtrs(v string) *NetView {
	t.LastCtrs = v
	return t
}

// SetData sets the [NetView.Data]:
// contains all the network data with history
func (t *NetView) SetData(v NetData) *NetView {
	t.Data = v
	return t
}

// SetDataMu sets the [NetView.DataMu]:
// mutex on data access
func (t *NetView) SetDataMu(v sync.RWMutex) *NetView {
	t.DataMu = v
	return t
}

// SetTooltip sets the [NetView.Tooltip]
func (t *NetView) SetTooltip(v string) *NetView {
	t.Tooltip = v
	return t
}

// SetClass sets the [NetView.Class]
func (t *NetView) SetClass(v string) *NetView {
	t.Class = v
	return t
}

// SetPriorityEvents sets the [NetView.PriorityEvents]
func (t *NetView) SetPriorityEvents(v []events.Types) *NetView {
	t.PriorityEvents = v
	return t
}

// SetCustomContextMenu sets the [NetView.CustomContextMenu]
func (t *NetView) SetCustomContextMenu(v func(m *gi.Scene)) *NetView {
	t.CustomContextMenu = v
	return t
}

// SetStackTop sets the [NetView.StackTop]
func (t *NetView) SetStackTop(v int) *NetView {
	t.StackTop = v
	return t
}

var _ = gti.AddType(&gti.Type{
	Name:      "github.com/emer/emergent/v2/netview.RasterParams",
	ShortName: "netview.RasterParams",
	IDName:    "raster-params",
	Doc:       "RasterParams holds parameters controlling the raster plot view",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"On", &gti.Field{Name: "On", Type: "bool", LocalType: "bool", Doc: "if true, show a raster plot over time, otherwise units", Directives: gti.Directives{}, Tag: ""}},
		{"XAxis", &gti.Field{Name: "XAxis", Type: "bool", LocalType: "bool", Doc: "if true, the raster counter (time) is plotted across the X axis -- otherwise the Z depth axis", Directives: gti.Directives{}, Tag: ""}},
		{"Max", &gti.Field{Name: "Max", Type: "int", LocalType: "int", Doc: "maximum count for the counter defining the raster plot", Directives: gti.Directives{}, Tag: ""}},
		{"UnitSize", &gti.Field{Name: "UnitSize", Type: "float32", LocalType: "float32", Doc: "size of a single unit, where 1 = full width and no space.. 1 default", Directives: gti.Directives{}, Tag: "min:\"0.1\" max:\"1\" step:\"0.1\" def:\"1\""}},
		{"UnitHeight", &gti.Field{Name: "UnitHeight", Type: "float32", LocalType: "float32", Doc: "height multiplier for units, where 1 = full height.. 0.2 default", Directives: gti.Directives{}, Tag: "min:\"0.1\" max:\"1\" step:\"0.1\" def:\"0.2\""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

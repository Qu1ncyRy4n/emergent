// Code generated by "core generate -add-types"; DO NOT EDIT.

package env

import (
	"cogentcore.org/core/types"
)

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.Ctr", IDName: "ctr", Doc: "Ctr is a counter that counts increments at a given time scale.\nIt keeps track of when it has been incremented or not, and\nretains the previous value.", Fields: []types.Field{{Name: "Cur", Doc: "current counter value"}, {Name: "Prv", Doc: "previous counter value, prior to last Incr() call (init to -1)"}, {Name: "Chg", Doc: "did this change on the last Step() call or not?"}, {Name: "Max", Doc: "where relevant, this is a fixed maximum counter value, above which the counter will reset back to 0 -- only used if > 0"}, {Name: "Scale", Doc: "the unit of time scale represented by this counter (just FYI)"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.Ctrs", IDName: "ctrs", Doc: "Ctrs contains an ordered slice of timescales,\nand a lookup map of counters by timescale\nused to manage counters in the Env.", Fields: []types.Field{{Name: "Order", Doc: "ordered list of the counter timescales, from outer-most (highest) to inner-most (lowest)"}, {Name: "Ctrs", Doc: "map of the counters by timescale"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.CurPrvF32", IDName: "cur-prv-f32", Doc: "CurPrvF32 is basic state management for current and previous values, float32 values", Fields: []types.Field{{Name: "Cur", Doc: "current value"}, {Name: "Prv", Doc: "previous value"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.CurPrvInt", IDName: "cur-prv-int", Doc: "CurPrvInt is basic state management for current and previous values, int values", Fields: []types.Field{{Name: "Cur", Doc: "current value"}, {Name: "Prv", Doc: "previous value"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.CurPrvString", IDName: "cur-prv-string", Doc: "CurPrvString is basic state management for current and previous values, string values", Fields: []types.Field{{Name: "Cur", Doc: "current value"}, {Name: "Prv", Doc: "previous value"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.Element", IDName: "element", Doc: "Element specifies one element of State or Action in an environment", Fields: []types.Field{{Name: "Name", Doc: "name of this element -- must be unique"}, {Name: "Shape", Doc: "shape of the tensor for this element -- each element should generally have a well-defined consistent shape to enable the model to process it consistently"}, {Name: "DimNames", Doc: "names of the dimensions within the Shape -- optional but useful for ensuring correct usage"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.Elements", IDName: "elements", Doc: "Elements is a list of Element info"})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.Env", IDName: "env", Doc: "Env defines an interface for environments, which determine the nature and\nsequence of States that can be used as inputs to a model, and the Env\nalso can accept Action responses from the model that affect state evolution.\n\nThe Env encapsulates all of the counter management logic to advance\nthe temporal state of the environment, using TimeScales standard\nintervals.\n\nState is comprised of one or more Elements, each of which consists of an\ntensor.Tensor chunk of values that can be obtained by the model.\nLikewise, Actions can also have Elements.  The Step method is the main\ninterface for advancing the Env state.  Counters should be queried\nafter calling Step to see if any relevant values have changed, to trigger\nfunctions in the model (e.g., logging of prior statistics, etc).\n\nTypically each specific implementation of this Env interface will have\nmultiple parameters etc that can be modified to control env behavior --\nall of this is paradigm-specific and outside the scope of this basic interface.", Directives: []types.Directive{{Tool: "go", Directive: "generate", Args: []string{"core", "generate", "-add-types"}}}, Methods: []types.Method{{Name: "Name", Doc: "Name returns a name for this environment, which can be useful\nfor selecting from a list of options etc.", Returns: []string{"string"}}, {Name: "Desc", Doc: "Desc returns an (optional) brief description of this particular\nenvironment", Returns: []string{"string"}}, {Name: "Validate", Doc: "Validate checks if the various specific parameters for this\nEnv have been properly set -- if not, error message(s) will\nbe returned.  If everything is OK, nil is returned, in which\ncase calls to Counters(), States(), and Actions() should all\nreturn valid data.  It is essential that a model *always* check\nthis as a first step, because the Env will not generally check\nfor errors on any subsequent calls (for greater efficiency\nand simplicity) and this call can also establish certain general\ninitialization settings that are not run-specific and thus make\nsense to do once at this point, not every time during Init().", Returns: []string{"error"}}, {Name: "Init", Doc: "Init initializes the environment for a given run of the model.\nThe environment may not care about the run number, but may implement\ndifferent parameterizations for different runs (e.g., between-subject\nmanipulations).  In general the Env can expect that the model will likely\nhave established a different random seed per run, prior to calling this\nmethod, and that may be sufficient to enable different run-level behavior.\nAll other initialization / updating beyond this outer-most Run level must\nbe managed internally by the Env itself, and the model can query the\nCounter state information to determine when things have updated at different\ntime scales.  See Step() for important info about state of env after Init\nbut prior to first Step() call.", Args: []string{"run"}}, {Name: "Step", Doc: "Step generates the next step of environment state.\nThis is the main API for how the model interacts with the environment --\nthe env should update all other levels of state internally over\nrepeated calls to the Step method.\nIf there are no further inputs available, it returns false (most envs\ntypically only return true and just continue running as long as needed).\n\nThe Env thus always reflects the *current* state of things, and this\ncall increments that current state, such that subsequent calls to\nState(), Counter() etc will return this current state.\nThis implies that the state just after Init and prior to first Step\ncall should be an *initialized* state that then allows the first Step\ncall to establish the proper *first* state.  Typically this means that\none or more counters will be set to -1 during Init and then get incremented\nto 0 on the first Step call.", Returns: []string{"bool"}}, {Name: "Counter", Doc: "Counter(scale TimeScales) returns current counter state for given time scale,\nthe immediate previous counter state, and whether that time scale changed\nduring the last Step() function call (this may be true even if cur == prv, if\nthe Max = 1).  Use the Ctr struct for each counter, which manages all of this.\nSee external Counter* methods for Python-safe single-return-value versions.", Args: []string{"scale"}, Returns: []string{"cur", "prv", "changed"}}, {Name: "State", Doc: "State returns the given element's worth of tensor data from the environment\nbased on the current state of the env, as a function of having called Step().\nIf no output is available on that element, then nil is returned.\nThe returned tensor must be treated as read-only as it likely points to original\nsource data -- please make a copy before modifying (e.g., Clone() methdod)", Args: []string{"element"}, Returns: []string{"Tensor"}}, {Name: "Action", Doc: "Action sends tensor data about e.g., responses from model back to act\non the environment and influence its subsequent evolution.\nThe nature and timing of this input is paradigm dependent.", Args: []string{"element", "input"}}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.EnvDesc", IDName: "env-desc", Doc: "EnvDesc is an interface that defines methods that describe an Env.\nThese are optional for basic Env, but in cases where an Env\nshould be fully self-describing, these methods can be implemented.", Methods: []types.Method{{Name: "Counters", Doc: "Counters returns []TimeScales list of counters supported by this env.\nThese should be consistent within a paradigm and most models\nwill just expect particular sets of counters, but this can be\nuseful for sanity checking that a suitable env has been selected.\nSee SchemaFromScales function that takes this list of time\nscales and returns an table.Schema for Table columns to record\nthese counters in a log.", Returns: []string{"TimeScales"}}, {Name: "States", Doc: "States returns a list of Elements of tensor outputs that this env\ngenerates, specifying the unique Name and Shape of the data.\nThis information can be derived directly from an table.Schema\nand used for configuring model input / output pathways to fit\nwith those provided by the environment.  Depending on the\nenv paradigm, all elements may not be always available at every\npoint in time e.g., an env might alternate between Action and Reward\nelements.  This may return nil if Env has not been properly\nconfigured.", Returns: []string{"Elements"}}, {Name: "Actions", Doc: "Actions returns a list of elements of tensor inputs that this env\naccepts, specifying the unique Name and Shape of the data.\nSpecific paradigms of envs can establish the timing and function\nof these inputs, and how they then affect subsequent outputs\ne.g., if the model is required to make a particular choice\nresponse and then it can receive a reward or not contingent\non that choice.", Returns: []string{"Elements"}}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.Envs", IDName: "envs", Doc: "Envs is a map of environments organized according\nto the evaluation mode string (recommended key value)"})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.FixedTable", IDName: "fixed-table", Doc: "FixedTable is a basic Env that manages patterns from an table.Table, with\neither sequential or permuted random ordering, and uses standard Trial / Epoch\nTimeScale counters to record progress and iterations through the table.\nIt also records the outer loop of Run as provided by the model.\nIt uses an IndexView indexed view of the Table, so a single shared table\ncan be used across different environments, with each having its own unique view.", Fields: []types.Field{{Name: "Nm", Doc: "name of this environment"}, {Name: "Dsc", Doc: "description of this environment"}, {Name: "Table", Doc: "this is an indexed view of the table with the set of patterns to output -- the indexes are used for the *sequential* view so you can easily sort / split / filter the patterns to be presented using this view -- we then add the random permuted Order on top of those if !sequential"}, {Name: "Sequential", Doc: "present items from the table in sequential order (i.e., according to the indexed view on the Table)?  otherwise permuted random order"}, {Name: "Order", Doc: "permuted order of items to present if not sequential -- updated every time through the list"}, {Name: "Run", Doc: "current run of model as provided during Init"}, {Name: "Epoch", Doc: "number of times through entire set of patterns"}, {Name: "Trial", Doc: "current ordinal item in Table -- if Sequential then = row number in table, otherwise is index in Order list that then gives row number in Table"}, {Name: "TrialName", Doc: "if Table has a Name column, this is the contents of that"}, {Name: "GroupName", Doc: "if Table has a Group column, this is contents of that"}, {Name: "NameCol", Doc: "name of the Name column -- defaults to 'Name'"}, {Name: "GroupCol", Doc: "name of the Group column -- defaults to 'Group'"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.FreqTable", IDName: "freq-table", Doc: "FreqTable is an Env that manages patterns from an table.Table with frequency\ninformation so that items are presented according to their associated frequencies\nwhich are effectively probabilities of presenting any given input -- must have\na Freq column with these numbers in the table (actual col name in FreqCol).\nEither sequential or permuted random ordering is supported, with std Trial / Epoch\nTimeScale counters to record progress and iterations through the table.\nIt also records the outer loop of Run as provided by the model.\nIt uses an IndexView indexed view of the Table, so a single shared table\ncan be used across different environments, with each having its own unique view.", Fields: []types.Field{{Name: "Nm", Doc: "name of this environment"}, {Name: "Dsc", Doc: "description of this environment"}, {Name: "Table", Doc: "this is an indexed view of the table with the set of patterns to output -- the indexes are used for the *sequential* view so you can easily sort / split / filter the patterns to be presented using this view -- we then add the random permuted Order on top of those if !sequential"}, {Name: "NSamples", Doc: "number of samples to use in constructing the list of items to present according to frequency -- number per epoch ~ NSamples * Freq -- see RandSamp option"}, {Name: "RandSamp", Doc: "if true, use random sampling of items NSamples times according to given Freq probability value -- otherwise just directly add NSamples * Freq items to the list"}, {Name: "Sequential", Doc: "present items from the table in sequential order (i.e., according to the indexed view on the Table)?  otherwise permuted random order.  All repetitions of given item will be sequential if Sequential"}, {Name: "Order", Doc: "list of items to present, with repetitions -- updated every time through the list"}, {Name: "Run", Doc: "current run of model as provided during Init"}, {Name: "Epoch", Doc: "number of times through entire set of patterns"}, {Name: "Trial", Doc: "current ordinal item in Table -- if Sequential then = row number in table, otherwise is index in Order list that then gives row number in Table"}, {Name: "TrialName", Doc: "if Table has a Name column, this is the contents of that"}, {Name: "GroupName", Doc: "if Table has a Group column, this is contents of that"}, {Name: "NameCol", Doc: "name of the Name column -- defaults to 'Name'"}, {Name: "GroupCol", Doc: "name of the Group column -- defaults to 'Group'"}, {Name: "FreqCol", Doc: "name of the Freq column -- defaults to 'Freq'"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.MPIFixedTable", IDName: "mpi-fixed-table", Doc: "MPIFixedTable is an MPI-enabled version of the FixedTable, which is\na basic Env that manages patterns from an table.Table, with\neither sequential or permuted random ordering, and uses standard Trial / Epoch\nTimeScale counters to record progress and iterations through the table.\nIt also records the outer loop of Run as provided by the model.\nIt uses an IndexView indexed view of the Table, so a single shared table\ncan be used across different environments, with each having its own unique view.\nThe MPI version distributes trials across MPI procs, in the Order list.\nIt is ESSENTIAL that the number of trials (rows) in Table is\nevenly divisible by number of MPI procs!\nIf all nodes start with the same seed, it should remain synchronized.", Fields: []types.Field{{Name: "Nm", Doc: "name of this environment"}, {Name: "Dsc", Doc: "description of this environment"}, {Name: "Table", Doc: "this is an indexed view of the table with the set of patterns to output -- the indexes are used for the *sequential* view so you can easily sort / split / filter the patterns to be presented using this view -- we then add the random permuted Order on top of those if !sequential"}, {Name: "Sequential", Doc: "present items from the table in sequential order (i.e., according to the indexed view on the Table)?  otherwise permuted random order"}, {Name: "Order", Doc: "permuted order of items to present if not sequential -- updated every time through the list"}, {Name: "Run", Doc: "current run of model as provided during Init"}, {Name: "Epoch", Doc: "number of times through entire set of patterns"}, {Name: "Trial", Doc: "current ordinal item in Table -- if Sequential then = row number in table, otherwise is index in Order list that then gives row number in Table"}, {Name: "TrialName", Doc: "if Table has a Name column, this is the contents of that"}, {Name: "GroupName", Doc: "if Table has a Group column, this is contents of that"}, {Name: "NameCol", Doc: "name of the Name column -- defaults to 'Name'"}, {Name: "GroupCol", Doc: "name of the Group column -- defaults to 'Group'"}, {Name: "TrialSt", Doc: "for MPI, trial we start each epoch on, as index into Order"}, {Name: "TrialEd", Doc: "for MPI, trial number we end each epoch before (i.e., when ctr gets to Ed, restarts)"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/env.TimeScales", IDName: "time-scales", Doc: "TimeScales are the different time scales associated with overall simulation running, and\ncan be used to parameterize the updating and control flow of simulations at different scales.\nThe definitions become increasingly subjective imprecise as the time scales increase.\nEnvironments can implement updating along different such time scales as appropriate.\nThis list is designed to standardize terminology across simulations and\nestablish a common conceptual framework for time -- it can easily be extended in specific\nsimulations to add needed additional levels, although using one of the existing standard\nvalues is recommended wherever possible."})

// Code generated by "core generate -add-types"; DO NOT EDIT.

package esg

import (
	"cogentcore.org/core/enums"
)

var _CondElsValues = []CondEls{0, 1, 2, 3, 4}

// CondElsN is the highest valid value for type CondEls, plus one.
const CondElsN CondEls = 5

var _CondElsValueMap = map[string]CondEls{`CRule`: 0, `And`: 1, `Or`: 2, `Not`: 3, `SubCond`: 4}

var _CondElsDescMap = map[CondEls]string{0: `CRule means Rule is name of a rule to evaluate truth value`, 1: ``, 2: ``, 3: ``, 4: `SubCond is a sub-condition expression`}

var _CondElsMap = map[CondEls]string{0: `CRule`, 1: `And`, 2: `Or`, 3: `Not`, 4: `SubCond`}

// String returns the string representation of this CondEls value.
func (i CondEls) String() string { return enums.String(i, _CondElsMap) }

// SetString sets the CondEls value from its string representation,
// and returns an error if the string is invalid.
func (i *CondEls) SetString(s string) error {
	return enums.SetString(i, s, _CondElsValueMap, "CondEls")
}

// Int64 returns the CondEls value as an int64.
func (i CondEls) Int64() int64 { return int64(i) }

// SetInt64 sets the CondEls value from an int64.
func (i *CondEls) SetInt64(in int64) { *i = CondEls(in) }

// Desc returns the description of the CondEls value.
func (i CondEls) Desc() string { return enums.Desc(i, _CondElsDescMap) }

// CondElsValues returns all possible values for the type CondEls.
func CondElsValues() []CondEls { return _CondElsValues }

// Values returns all possible values for the type CondEls.
func (i CondEls) Values() []enums.Enum { return enums.Values(_CondElsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i CondEls) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *CondEls) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "CondEls") }

var _ElementsValues = []Elements{0, 1}

// ElementsN is the highest valid value for type Elements, plus one.
const ElementsN Elements = 2

var _ElementsValueMap = map[string]Elements{`RuleEl`: 0, `TokenEl`: 1}

var _ElementsDescMap = map[Elements]string{0: `RuleEl means Value is name of a rule`, 1: `TokenEl means Value is a token to emit`}

var _ElementsMap = map[Elements]string{0: `RuleEl`, 1: `TokenEl`}

// String returns the string representation of this Elements value.
func (i Elements) String() string { return enums.String(i, _ElementsMap) }

// SetString sets the Elements value from its string representation,
// and returns an error if the string is invalid.
func (i *Elements) SetString(s string) error {
	return enums.SetString(i, s, _ElementsValueMap, "Elements")
}

// Int64 returns the Elements value as an int64.
func (i Elements) Int64() int64 { return int64(i) }

// SetInt64 sets the Elements value from an int64.
func (i *Elements) SetInt64(in int64) { *i = Elements(in) }

// Desc returns the description of the Elements value.
func (i Elements) Desc() string { return enums.Desc(i, _ElementsDescMap) }

// ElementsValues returns all possible values for the type Elements.
func ElementsValues() []Elements { return _ElementsValues }

// Values returns all possible values for the type Elements.
func (i Elements) Values() []enums.Enum { return enums.Values(_ElementsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Elements) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Elements) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "Elements") }

var _RuleTypesValues = []RuleTypes{0, 1, 2, 3, 4}

// RuleTypesN is the highest valid value for type RuleTypes, plus one.
const RuleTypesN RuleTypes = 5

var _RuleTypesValueMap = map[string]RuleTypes{`UniformItems`: 0, `ProbItems`: 1, `CondItems`: 2, `SequentialItems`: 3, `PermutedItems`: 4}

var _RuleTypesDescMap = map[RuleTypes]string{0: `UniformItems is the default mutually exclusive items chosen at uniform random`, 1: `ProbItems has specific probabilities for each item`, 2: `CondItems has conditionals for each item, indicated by ?`, 3: `SequentialItems progresses through items in sequential order, indicated by |`, 4: `PermutedItems progresses through items in permuted order, indicated by $`}

var _RuleTypesMap = map[RuleTypes]string{0: `UniformItems`, 1: `ProbItems`, 2: `CondItems`, 3: `SequentialItems`, 4: `PermutedItems`}

// String returns the string representation of this RuleTypes value.
func (i RuleTypes) String() string { return enums.String(i, _RuleTypesMap) }

// SetString sets the RuleTypes value from its string representation,
// and returns an error if the string is invalid.
func (i *RuleTypes) SetString(s string) error {
	return enums.SetString(i, s, _RuleTypesValueMap, "RuleTypes")
}

// Int64 returns the RuleTypes value as an int64.
func (i RuleTypes) Int64() int64 { return int64(i) }

// SetInt64 sets the RuleTypes value from an int64.
func (i *RuleTypes) SetInt64(in int64) { *i = RuleTypes(in) }

// Desc returns the description of the RuleTypes value.
func (i RuleTypes) Desc() string { return enums.Desc(i, _RuleTypesDescMap) }

// RuleTypesValues returns all possible values for the type RuleTypes.
func RuleTypesValues() []RuleTypes { return _RuleTypesValues }

// Values returns all possible values for the type RuleTypes.
func (i RuleTypes) Values() []enums.Enum { return enums.Values(_RuleTypesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i RuleTypes) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *RuleTypes) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "RuleTypes")
}

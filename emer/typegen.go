// Code generated by "core generate -add-types"; DO NOT EDIT.

package emer

import (
	"cogentcore.org/core/types"
)

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.Layer", IDName: "layer", Doc: "Layer defines the minimal interface for neural network layers,\nnecessary to support the visualization (NetView), I/O,\nand parameter setting functionality provided by emergent.\nMost of the standard expected functionality is defined in the\nLayerBase struct, and this interface only has methods that must be\nimplemented specifically for a given algorithmic implementation.", Methods: []types.Method{{Name: "AsEmer", Doc: "AsEmer returns the layer as an *emer.LayerBase,\nto access base functionality.", Returns: []string{"LayerBase"}}, {Name: "Label", Doc: "Label satisfies the core.Labeler interface for getting\nthe name of objects generically.", Returns: []string{"string"}}, {Name: "TypeName", Doc: "TypeName is the type or category of layer, defined\nby the algorithm (and usually set by an enum).", Returns: []string{"string"}}, {Name: "UnitVarNames", Doc: "UnitVarNames returns a list of variable names available\non the units in this layer.\nThis is typically a global list so do not modify!", Returns: []string{"[]string"}}, {Name: "UnitVarProps", Doc: "UnitVarProps returns a map of unit variable properties,\nwith the key being the name of the variable, and the\nvalue gives a space-separated list of\ngo-tag-style properties for that variable.\nThe NetView recognizes the following properties:\nrange:\"##\" = +- range around 0 for default display scaling\nmin:\"##\" max:\"##\" = min, max display range\nauto-scale:\"+\" or \"-\" = use automatic scaling instead of fixed\nrange or not.\nzeroctr:\"+\" or \"-\" = control whether zero-centering is used\ndesc:\"txt\" tooltip description of the variable\nNote: this is a global list so do not modify!", Returns: []string{"map[string]string"}}, {Name: "UnitVarIndex", Doc: "UnitVarIndex returns the index of given variable within\nthe Neuron, according to *this layer's* UnitVarNames() list\n(using a map to lookup index), or -1 and error message if\nnot found.", Args: []string{"varNm"}, Returns: []string{"int", "error"}}, {Name: "UnitVarNum", Doc: "UnitVarNum returns the number of Neuron-level variables\nfor this layer.  This is needed for extending indexes in\nderived types.", Returns: []string{"int"}}, {Name: "UnitVal1D", Doc: "UnitVal1D returns value of given variable index on given unit,\nusing 1-dimensional index, and a data parallel index di,\nfor networks capable of processing multiple input patterns\nin parallel. Returns NaN on invalid index.\nThis is the core unit var access method used by other methods,\nso it is the only one that needs to be updated for derived layer types.", Args: []string{"varIndex", "idx", "di"}, Returns: []string{"float32"}}, {Name: "VarRange", Doc: "VarRange returns the min / max values for given variable\nover the layer", Args: []string{"varNm"}, Returns: []string{"min", "max", "err"}}, {Name: "NumRecvPaths", Doc: "NumRecvPaths returns the number of receiving pathways.", Returns: []string{"int"}}, {Name: "RecvPath", Doc: "RecvPath returns a specific receiving pathway.", Args: []string{"idx"}, Returns: []string{"Path"}}, {Name: "NumSendPaths", Doc: "NumSendPaths returns the number of sending pathways.", Returns: []string{"int"}}, {Name: "SendPath", Doc: "SendPath returns a specific sending pathway.", Args: []string{"idx"}, Returns: []string{"Path"}}, {Name: "RecvPathValues", Doc: "RecvPathValues fills in values of given synapse variable name,\nfor pathway from given sending layer and neuron 1D index,\nfor all receiving neurons in this layer,\ninto given float32 slice (only resized if not big enough).\npathType is the string representation of the path type;\nused if non-empty, useful when there are multiple pathways\nbetween two layers.\nReturns error on invalid var name.\nIf the receiving neuron is not connected to the given sending\nlayer or neuron then the value is set to math32.NaN().\nReturns error on invalid var name or lack of recv path\n(vals always set to nan on path err).", Args: []string{"vals", "varNm", "sendLay", "sendIndex1D", "pathType"}, Returns: []string{"error"}}, {Name: "SendPathValues", Doc: "SendPathValues fills in values of given synapse variable name,\nfor pathway into given receiving layer and neuron 1D index,\nfor all sending neurons in this layer,\ninto given float32 slice (only resized if not big enough).\npathType is the string representation of the path type -- used if non-empty,\nuseful when there are multiple pathways between two layers.\nReturns error on invalid var name.\nIf the sending neuron is not connected to the given receiving layer or neuron\nthen the value is set to math32.NaN().\nReturns error on invalid var name or lack of recv path (vals always set to nan on path err).", Args: []string{"vals", "varNm", "recvLay", "recvIndex1D", "pathType"}, Returns: []string{"error"}}, {Name: "UpdateParams", Doc: "UpdateParams() updates parameter values for all Layer\nand recv pathway parameters,\nbased on any other params that might have changed."}, {Name: "ApplyParams", Doc: "ApplyParams applies given parameter style Sheet to this\nlayer and its recv pathways.\nCalls UpdateParams on anything set to ensure derived\nparameters are all updated.\nIf setMsg is true, then a message is printed to confirm\neach parameter that is set.\nit always prints a message if a parameter fails to be set.\nreturns true if any params were set, and error if\nthere were any errors.", Args: []string{"pars", "setMsg"}, Returns: []string{"bool", "error"}}, {Name: "SetParam", Doc: "SetParam sets parameter at given path to given value.\nreturns error if path not found or value cannot be set.", Args: []string{"path", "val"}, Returns: []string{"error"}}, {Name: "NonDefaultParams", Doc: "NonDefaultParams returns a listing of all parameters in the Layer that\nare not at their default values -- useful for setting param styles etc.", Returns: []string{"string"}}, {Name: "AllParams", Doc: "AllParams returns a listing of all parameters in the Layer", Returns: []string{"string"}}, {Name: "WriteWtsJSON", Doc: "WriteWtsJSON writes the weights from this layer from the\nreceiver-side perspective in a JSON text format.\nWe build in the indentation logic to make it much faster and\nmore efficient.", Args: []string{"w", "depth"}}, {Name: "ReadWtsJSON", Doc: "ReadWtsJSON reads the weights from this layer from the\nreceiver-side perspective in a JSON text format.\nThis is for a set of weights that were saved\n*for one layer only* and is not used for the\nnetwork-level ReadWtsJSON, which reads into a separate\nstructure -- see SetWts method.", Args: []string{"r"}, Returns: []string{"error"}}, {Name: "SetWts", Doc: "SetWts sets the weights for this layer from weights.Layer\ndecoded values", Args: []string{"lw"}, Returns: []string{"error"}}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.LayerBase", IDName: "layer-base", Doc: "LayerBase defines the basic shared data for neural network layers,\nused for managing the structural elements of a network,\nand for visualization, I/O, etc.\nNothing algorithm-specific is implemented here", Fields: []types.Field{{Name: "EmerLayer", Doc: "EmerLayer provides access to the emer.Layer interface\nmethods for functions defined in the LayerBase type.\nMust set this with a pointer to the actual instance\nwhen created, using InitLayer function."}, {Name: "Name", Doc: "Name of the layer, which must be unique within the network.\nLayers are typically accessed directly by name, via a map."}, {Name: "Class", Doc: "Class is for applying parameter styles across multiple layers\nthat all get the same parameters.  This can be space separated\nwith multple classes."}, {Name: "Shape", Doc: "Shape of the layer, either 2D or 4D.  Although spatial topology\nis not relevant to all algorithms, the 2D shape is important for\nefficiently visualizing large numbers of units / neurons.\n4D layers have 2D Pools of units embedded within a larger 2D\norganization of such pools.  This is used for max-pooling or\npooled inhibition at a finer-grained level, and biologically\ncorresopnds to hypercolumns in the cortex for example.\nOrder is outer-to-inner (row major), so Y then X for 2D;\n4D: Y-X unit pools then Y-X neurons within pools."}, {Name: "Pos", Doc: "Pos specifies the relative spatial relationship to another\nlayer, which determines positioning.  Every layer except one\n\"anchor\" layer should be positioned relative to another,\ne.g., RightOf, Above, etc.  This provides robust positioning\nin the face of layer size changes etc.\nLayers are arranged in X-Y planes, stacked vertically along the Z axis."}, {Name: "Index", Doc: "Index is a 0..n-1 index of the position of the layer within\nthe list of layers in the network."}, {Name: "SampleIndexes", Doc: "SampleIndexes are the current set of \"sample\" unit indexes,\nwhich are a smaller subset of units that represent the behavior\nof the layer, for computationally intensive statistics and displays\n(e.g., PCA, ActRF, NetView rasters), when the layer is large.\nIf none have been set, then all units are used.\nSee utility function CenterPoolIndexes that returns indexes of\nunits in the central pools of a 4D layer."}, {Name: "SampleShape", Doc: "SampleShape is the shape to use for the subset of sample\nunit indexes, in terms of an array of dimensions.\nSee Shape for more info.\nLayers that set SampleIndexes should also set this,\notherwise a 1D array of len SampleIndexes will be used.\nSee utility function CenterPoolShape that returns shape of\nunits in the central pools of a 4D layer."}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.LayNames", IDName: "lay-names", Doc: "LayNames is a list of layer names.\nHas convenience methods for adding, validating."})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.NetParams", IDName: "net-params", Doc: "NetParams handles standard parameters for a Network\n(use econfig and a Config struct for other configuration params).\nAssumes a Set named \"Base\" has the base-level parameters, which are\nalways applied first, followed optionally by additional Set(s)\nthat can have different parameters to try.", Fields: []types.Field{{Name: "Params", Doc: "full collection of param sets to use"}, {Name: "ExtraSheets", Doc: "optional additional sheets of parameters to apply after Base -- can use multiple names separated by spaces (don't put spaces in Sheet names!)"}, {Name: "Tag", Doc: "optional additional tag to add to file names, logs to identify params / run config"}, {Name: "Network", Doc: "the network to apply parameters to"}, {Name: "NetHypers", Doc: "list of hyper parameters compiled from the network parameters, using the layers and pathways from the network, so that the same styling logic as for regular parameters can be used"}, {Name: "SetMsg", Doc: "print out messages for each parameter that is set"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.LaySize", IDName: "lay-size", Doc: "LaySize contains parameters for size of layers", Fields: []types.Field{{Name: "Y", Doc: "Y (vertical) size of layer -- in units for 2D, or number of pools (outer dimension) for 4D layer"}, {Name: "X", Doc: "X (horizontal) size of layer -- in units for 2D, or number of pools (outer dimension) for 4D layer"}, {Name: "PoolY", Doc: "Y (vertical) size of each pool in units, only for 4D layers (inner dimension)"}, {Name: "PoolX", Doc: "Y (horizontal) size of each pool in units, only for 4D layers (inner dimension)"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.NetSize", IDName: "net-size", Doc: "NetSize is a network schema for holding a params for layer sizes.\nValues can be queried for getting sizes when configuring the network.\nUses params.Flex to support flexible parameter specification"})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.Network", IDName: "network", Doc: "Network defines the basic interface for a neural network, used for managing the structural\nelements of a network, and for visualization, I/O, etc", Methods: []types.Method{{Name: "InitName", Doc: "InitName MUST be called to initialize the network's pointer to itself as an emer.Network\nwhich enables the proper interface methods to be called.  Also sets the name.", Args: []string{"net", "name"}}, {Name: "Name", Doc: "Name() returns name of the network", Returns: []string{"string"}}, {Name: "Label", Doc: "Label satisfies the core.Labeler interface for getting the name of objects generically", Returns: []string{"string"}}, {Name: "NLayers", Doc: "NLayers returns the number of layers in the network", Returns: []string{"int"}}, {Name: "Layer", Doc: "Layer returns layer (as emer.Layer interface) at given index -- does not\ndo extra bounds checking", Args: []string{"idx"}, Returns: []string{"Layer"}}, {Name: "LayerByName", Doc: "LayerByName returns layer of given name, nil if not found.\nLayer names must be unique and a map is used so this is a fast operation", Args: []string{"name"}, Returns: []string{"Layer"}}, {Name: "LayerByNameTry", Doc: "LayerByNameTry returns layer of given name, returns error if not found.\nLayer names must be unique and a map is used so this is a fast operation", Args: []string{"name"}, Returns: []string{"Layer", "error"}}, {Name: "PathByNameTry", Doc: "PathByNameTry returns path of given name, returns error if not found.\nPath names are SendToRecv, and are looked up by parsing the name", Args: []string{"name"}, Returns: []string{"Path", "error"}}, {Name: "Defaults", Doc: "Defaults sets default parameter values for everything in the Network"}, {Name: "UpdateParams", Doc: "UpdateParams() updates parameter values for all Network parameters,\nbased on any other params that might have changed."}, {Name: "ApplyParams", Doc: "ApplyParams applies given parameter style Sheet to layers and paths in this network.\nCalls UpdateParams on anything set to ensure derived parameters are all updated.\nIf setMsg is true, then a message is printed to confirm each parameter that is set.\nit always prints a message if a parameter fails to be set.\nreturns true if any params were set, and error if there were any errors.", Args: []string{"pars", "setMsg"}, Returns: []string{"bool", "error"}}, {Name: "NonDefaultParams", Doc: "NonDefaultParams returns a listing of all parameters in the Network that\nare not at their default values -- useful for setting param styles etc.", Returns: []string{"string"}}, {Name: "AllParams", Doc: "AllParams returns a listing of all parameters in the Network", Returns: []string{"string"}}, {Name: "KeyLayerParams", Doc: "KeyLayerParams returns a listing for all layers in the network,\nof the most important layer-level params (specific to each algorithm).", Returns: []string{"string"}}, {Name: "KeyPathParams", Doc: "KeyPathParams returns a listing for all Recv pathways in the network,\nof the most important pathway-level params (specific to each algorithm).", Returns: []string{"string"}}, {Name: "UnitVarNames", Doc: "UnitVarNames returns a list of variable names available on the units in this network.\nThis list determines what is shown in the NetView (and the order of vars list).\nNot all layers need to support all variables, but must safely return math32.NaN() for\nunsupported ones.\nThis is typically a global list so do not modify!", Returns: []string{"[]string"}}, {Name: "UnitVarProps", Doc: "UnitVarProps returns a map of unit variable properties, with the key being the\nname of the variable, and the value gives a space-separated list of\ngo-tag-style properties for that variable.\nThe NetView recognizes the following properties:\nrange:\"##\" = +- range around 0 for default display scaling\nmin:\"##\" max:\"##\" = min, max display range\nauto-scale:\"+\" or \"-\" = use automatic scaling instead of fixed range or not.\nzeroctr:\"+\" or \"-\" = control whether zero-centering is used\ndesc:\"txt\" tooltip description of the variable\nNote: this is typically a global list so do not modify!", Returns: []string{"map[string]string"}}, {Name: "SynVarNames", Doc: "SynVarNames returns the names of all the variables on the synapses in this network.\nThis list determines what is shown in the NetView (and the order of vars list).\nNot all pathways need to support all variables, but must safely return math32.NaN() for\nunsupported ones.\nThis is typically a global list so do not modify!", Returns: []string{"[]string"}}, {Name: "SynVarProps", Doc: "SynVarProps returns a map of synapse variable properties, with the key being the\nname of the variable, and the value gives a space-separated list of\ngo-tag-style properties for that variable.\nThe NetView recognizes the following properties:\nrange:\"##\" = +- range around 0 for default display scaling\nmin:\"##\" max:\"##\" = min, max display range\nauto-scale:\"+\" or \"-\" = use automatic scaling instead of fixed range or not.\nzeroctr:\"+\" or \"-\" = control whether zero-centering is used\nNote: this is typically a global list so do not modify!", Returns: []string{"map[string]string"}}, {Name: "WriteWtsJSON", Doc: "WriteWtsJSON writes network weights (and any other state that adapts with learning)\nto JSON-formatted output.", Args: []string{"w"}, Returns: []string{"error"}}, {Name: "ReadWtsJSON", Doc: "ReadWtsJSON reads network weights (and any other state that adapts with learning)\nfrom JSON-formatted input.  Reads into a temporary weights.Network structure that\nis then passed to SetWts to actually set the weights.", Args: []string{"r"}, Returns: []string{"error"}}, {Name: "SetWts", Doc: "SetWts sets the weights for this network from weights.Network decoded values", Args: []string{"nw"}, Returns: []string{"error"}}, {Name: "SaveWtsJSON", Doc: "SaveWtsJSON saves network weights (and any other state that adapts with learning)\nto a JSON-formatted file.  If filename has .gz extension, then file is gzip compressed.", Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "OpenWtsJSON", Doc: "OpenWtsJSON opens network weights (and any other state that adapts with learning)\nfrom a JSON-formatted file.  If filename has .gz extension, then file is gzip uncompressed.", Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "Bounds", Doc: "Bounds returns the minimum and maximum display coordinates of the network for 3D display", Returns: []string{"min", "max"}}, {Name: "VarRange", Doc: "VarRange returns the min / max values for given variable", Args: []string{"varNm"}, Returns: []string{"min", "max", "err"}}, {Name: "LayersByClass", Doc: "LayersByClass returns a list of layer names by given class(es).\nLists are compiled when network Build() function called.\nThe layer Type is always included as a Class, along with any other\nspace-separated strings specified in Class for parameter styling, etc.\nIf no classes are passed, all layer names in order are returned.", Args: []string{"classes"}, Returns: []string{"[]string"}}, {Name: "MaxParallelData", Doc: "MaxParallelData returns the maximum number of data inputs that can be\nprocessed in parallel by the network.\nThe NetView supports display of up to this many data elements.", Returns: []string{"int"}}, {Name: "NParallelData", Doc: "NParallelData returns the current number of data inputs currently being\nprocessed in parallel by the network.\nLogging supports recording each of these where appropriate.", Returns: []string{"int"}}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.Path", IDName: "path", Doc: "Path defines the minimal interface for a pathway\nwhich connects two layers, using a specific Pattern\nof connectivity, and with its own set of parameters.\nThis supports visualization (NetView), I/O,\nand parameter setting functionality provided by emergent.\nMost of the standard expected functionality is defined in the\nPathBase struct, and this interface only has methods that must be\nimplemented specifically for a given algorithmic implementation,", Methods: []types.Method{{Name: "AsEmer", Doc: "AsEmer returns the path as an *emer.PathBase,\nto access base functionality.", Returns: []string{"PathBase"}}, {Name: "Label", Doc: "Label satisfies the core.Labeler interface for getting\nthe name of objects generically.", Returns: []string{"string"}}, {Name: "TypeName", Doc: "TypeName is the type or category of path, defined\nby the algorithm (and usually set by an enum).", Returns: []string{"string"}}, {Name: "SendLayer", Doc: "SendLayer returns the sending layer for this pathway,\nas an emer.Layer interface.  The actual Path implmenetation\ncan use a Send field with the actual Layer struct type.", Returns: []string{"Layer"}}, {Name: "RecvLayer", Doc: "RecvLayer returns the receiving layer for this pathway,\nas an emer.Layer interface.  The actual Path implmenetation\ncan use a Recv field with the actual Layer struct type.", Returns: []string{"Layer"}}, {Name: "SynVarNames", Doc: "SynVarNames returns the names of all the variables on the synapse\nThis is typically a global list so do not modify!", Returns: []string{"[]string"}}, {Name: "SynVarProps", Doc: "SynVarProps returns a map of synapse variable properties, with the key being the\nname of the variable, and the value gives a space-separated list of\ngo-tag-style properties for that variable.\nThe NetView recognizes the following properties:\nrange:\"##\" = +- range around 0 for default display scaling\nmin:\"##\" max:\"##\" = min, max display range\nauto-scale:\"+\" or \"-\" = use automatic scaling instead of fixed range or not.\nzeroctr:\"+\" or \"-\" = control whether zero-centering is used\nNote: this is a global list so do not modify!", Returns: []string{"map[string]string"}}, {Name: "SynIndex", Doc: "SynIndex returns the index of the synapse between given send, recv unit indexes\n(1D, flat indexes). Returns -1 if synapse not found between these two neurons.\nThis requires searching within connections for receiving unit (a bit slow).", Args: []string{"sidx", "ridx"}, Returns: []string{"int"}}, {Name: "SynVarIndex", Doc: "SynVarIndex returns the index of given variable within the synapse,\naccording to *this path's* SynVarNames() list (using a map to lookup index),\nor -1 and error message if not found.", Args: []string{"varNm"}, Returns: []string{"int", "error"}}, {Name: "SynVarNum", Doc: "SynVarNum returns the number of synapse-level variables\nfor this paths.  This is needed for extending indexes in derived types.", Returns: []string{"int"}}, {Name: "NumSyns", Doc: "NumSyns returns the number of synapses for this path.\nThis is the max idx for SynValue1D and the number\nof vals set by SynValues.", Returns: []string{"int"}}, {Name: "SynValue1D", Doc: "SynValue1D returns value of given variable index\n(from SynVarIndex) on given SynIndex.\nReturns NaN on invalid index.\nThis is the core synapse var access method used by other methods,\nso it is the only one that needs to be updated for derived types.", Args: []string{"varIndex", "synIndex"}, Returns: []string{"float32"}}, {Name: "UpdateParams", Doc: "UpdateParams() updates parameter values for all Path parameters,\nbased on any other params that might have changed."}, {Name: "ApplyParams", Doc: "ApplyParams applies given parameter style Sheet to this pathway.\nCalls UpdateParams if anything set to ensure derived\nparameters are all updated.\nIf setMsg is true, then a message is printed to confirm each\nparameter that is set.\nIt always prints a message if a parameter fails to be set.\nreturns true if any params were set, and error if there were any errors.", Args: []string{"pars", "setMsg"}, Returns: []string{"bool", "error"}}, {Name: "SetParam", Doc: "SetParam sets parameter at given path to given value.\nreturns error if path not found or value cannot be set.", Args: []string{"path", "val"}, Returns: []string{"error"}}, {Name: "NonDefaultParams", Doc: "NonDefaultParams returns a listing of all parameters in the Projection that\nare not at their default values -- useful for setting param styles etc.", Returns: []string{"string"}}, {Name: "AllParams", Doc: "AllParams returns a listing of all parameters in the Projection", Returns: []string{"string"}}, {Name: "WriteWtsJSON", Doc: "WriteWtsJSON writes the weights from this pathway\nfrom the receiver-side perspective in a JSON text format.\nWe build in the indentation logic to make it much faster and\nmore efficient.", Args: []string{"w", "depth"}}, {Name: "ReadWtsJSON", Doc: "ReadWtsJSON reads the weights from this pathway\nfrom the receiver-side perspective in a JSON text format.\nThis is for a set of weights that were saved *for one path only*\nand is not used for the network-level ReadWtsJSON,\nwhich reads into a separate structure -- see SetWts method.", Args: []string{"r"}, Returns: []string{"error"}}, {Name: "SetWts", Doc: "SetWts sets the weights for this pathway from weights.Path\ndecoded values", Args: []string{"pw"}, Returns: []string{"error"}}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.PathBase", IDName: "path-base", Doc: "PathBase defines the basic shared data for a pathway\nwhich connects two layers, using a specific Pattern\nof connectivity, and with its own set of parameters.\nName is set automatically to:\nNothing algorithm-specific is implemented here.", Fields: []types.Field{{Name: "EmerPath", Doc: "EmerPath provides access to the emer.Path interface\nmethods for functions defined in the PathBase type.\nMust set this with a pointer to the actual instance\nwhen created, using InitPath function."}, {Name: "Name", Doc: "Name of the path, which can be automatically set to\nSendLayer().Name + \"To\" + RecvLayer().Name via\nSetStandardName method."}, {Name: "Class", Doc: "Class is for applying parameter styles across multiple paths\nthat all get the same parameters.  This can be space separated\nwith multple classes."}, {Name: "Pattern", Doc: "Pattern specifies the pattern of connectivity\nfor interconnecting the sending and receiving layers."}}})

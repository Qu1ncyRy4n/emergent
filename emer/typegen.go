// Code generated by "core generate -add-types"; DO NOT EDIT.

package emer

import (
	"cogentcore.org/core/types"
)

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.Layer", IDName: "layer", Doc: "Layer defines the minimal interface for neural network layers,\nnecessary to support the visualization (NetView), I/O,\nand parameter setting functionality provided by emergent.\nMost of the standard expected functionality is defined in the\nLayerBase struct, and this interface only has methods that must be\nimplemented specifically for a given algorithmic implementation.", Methods: []types.Method{{Name: "AsEmer", Doc: "AsEmer returns the layer as an *emer.LayerBase,\nto access base functionality.", Returns: []string{"LayerBase"}}, {Name: "Label", Doc: "Label satisfies the core.Labeler interface for getting\nthe name of objects generically.", Returns: []string{"string"}}, {Name: "TypeName", Doc: "TypeName is the type or category of layer, defined\nby the algorithm (and usually set by an enum).", Returns: []string{"string"}}, {Name: "UnitVarIndex", Doc: "UnitVarIndex returns the index of given variable within\nthe Neuron, according to *this layer's* UnitVarNames() list\n(using a map to lookup index), or -1 and error message if\nnot found.", Args: []string{"varNm"}, Returns: []string{"int", "error"}}, {Name: "UnitVal1D", Doc: "UnitVal1D returns value of given variable index on given unit,\nusing 1-dimensional index, and a data parallel index di,\nfor networks capable of processing multiple input patterns\nin parallel. Returns NaN on invalid index.\nThis is the core unit var access method used by other methods,\nso it is the only one that needs to be updated for derived layer types.", Args: []string{"varIndex", "idx", "di"}, Returns: []string{"float32"}}, {Name: "NumRecvPaths", Doc: "NumRecvPaths returns the number of receiving pathways.", Returns: []string{"int"}}, {Name: "RecvPath", Doc: "RecvPath returns a specific receiving pathway.", Args: []string{"idx"}, Returns: []string{"Path"}}, {Name: "NumSendPaths", Doc: "NumSendPaths returns the number of sending pathways.", Returns: []string{"int"}}, {Name: "SendPath", Doc: "SendPath returns a specific sending pathway.", Args: []string{"idx"}, Returns: []string{"Path"}}, {Name: "RecvPathValues", Doc: "RecvPathValues fills in values of given synapse variable name,\nfor pathway from given sending layer and neuron 1D index,\nfor all receiving neurons in this layer,\ninto given float32 slice (only resized if not big enough).\npathType is the string representation of the path type;\nused if non-empty, useful when there are multiple pathways\nbetween two layers.\nReturns error on invalid var name.\nIf the receiving neuron is not connected to the given sending\nlayer or neuron then the value is set to math32.NaN().\nReturns error on invalid var name or lack of recv path\n(vals always set to nan on path err).", Args: []string{"vals", "varNm", "sendLay", "sendIndex1D", "pathType"}, Returns: []string{"error"}}, {Name: "SendPathValues", Doc: "SendPathValues fills in values of given synapse variable name,\nfor pathway into given receiving layer and neuron 1D index,\nfor all sending neurons in this layer,\ninto given float32 slice (only resized if not big enough).\npathType is the string representation of the path type -- used if non-empty,\nuseful when there are multiple pathways between two layers.\nReturns error on invalid var name.\nIf the sending neuron is not connected to the given receiving layer or neuron\nthen the value is set to math32.NaN().\nReturns error on invalid var name or lack of recv path (vals always set to nan on path err).", Args: []string{"vals", "varNm", "recvLay", "recvIndex1D", "pathType"}, Returns: []string{"error"}}, {Name: "UpdateParams", Doc: "UpdateParams() updates parameter values for all Layer\nand recv pathway parameters,\nbased on any other params that might have changed."}, {Name: "ApplyParams", Doc: "ApplyParams applies given parameter style Sheet to this\nlayer and its recv pathways.\nCalls UpdateParams on anything set to ensure derived\nparameters are all updated.\nIf setMsg is true, then a message is printed to confirm\neach parameter that is set.\nit always prints a message if a parameter fails to be set.\nreturns true if any params were set, and error if\nthere were any errors.", Args: []string{"pars", "setMsg"}, Returns: []string{"bool", "error"}}, {Name: "SetParam", Doc: "SetParam sets parameter at given path to given value.\nreturns error if path not found or value cannot be set.", Args: []string{"path", "val"}, Returns: []string{"error"}}, {Name: "NonDefaultParams", Doc: "NonDefaultParams returns a listing of all parameters in the Layer that\nare not at their default values -- useful for setting param styles etc.", Returns: []string{"string"}}, {Name: "AllParams", Doc: "AllParams returns a listing of all parameters in the Layer", Returns: []string{"string"}}, {Name: "WriteWtsJSON", Doc: "WriteWtsJSON writes the weights from this layer from the\nreceiver-side perspective in a JSON text format.\nWe build in the indentation logic to make it much faster and\nmore efficient.", Args: []string{"w", "depth"}}, {Name: "ReadWtsJSON", Doc: "ReadWtsJSON reads the weights from this layer from the\nreceiver-side perspective in a JSON text format.\nThis is for a set of weights that were saved\n*for one layer only* and is not used for the\nnetwork-level ReadWtsJSON, which reads into a separate\nstructure -- see SetWts method.", Args: []string{"r"}, Returns: []string{"error"}}, {Name: "SetWts", Doc: "SetWts sets the weights for this layer from weights.Layer\ndecoded values", Args: []string{"lw"}, Returns: []string{"error"}}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.LayerBase", IDName: "layer-base", Doc: "LayerBase defines the basic shared data for neural network layers,\nused for managing the structural elements of a network,\nand for visualization, I/O, etc.\nNothing algorithm-specific is implemented here", Fields: []types.Field{{Name: "EmerLayer", Doc: "EmerLayer provides access to the emer.Layer interface\nmethods for functions defined in the LayerBase type.\nMust set this with a pointer to the actual instance\nwhen created, using InitLayer function."}, {Name: "Name", Doc: "Name of the layer, which must be unique within the network.\nLayers are typically accessed directly by name, via a map."}, {Name: "Info", Doc: "Info contains descriptive information about the layer.\nThis is displayed in a tooltip in the network view."}, {Name: "Class", Doc: "Class is for applying parameter styles across multiple layers\nthat all get the same parameters.  This can be space separated\nwith multple classes."}, {Name: "Off", Doc: "Off turns off the layer, removing from all computations.\nThis provides a convenient way to dynamically test for\nthe contributions of the layer, for example."}, {Name: "Shape", Doc: "Shape of the layer, either 2D or 4D.  Although spatial topology\nis not relevant to all algorithms, the 2D shape is important for\nefficiently visualizing large numbers of units / neurons.\n4D layers have 2D Pools of units embedded within a larger 2D\norganization of such pools.  This is used for max-pooling or\npooled inhibition at a finer-grained level, and biologically\ncorresopnds to hypercolumns in the cortex for example.\nOrder is outer-to-inner (row major), so Y then X for 2D;\n4D: Y-X unit pools then Y-X neurons within pools."}, {Name: "Pos", Doc: "Pos specifies the relative spatial relationship to another\nlayer, which determines positioning.  Every layer except one\n\"anchor\" layer should be positioned relative to another,\ne.g., RightOf, Above, etc.  This provides robust positioning\nin the face of layer size changes etc.\nLayers are arranged in X-Y planes, stacked vertically along the Z axis."}, {Name: "Index", Doc: "Index is a 0..n-1 index of the position of the layer within\nthe list of layers in the network."}, {Name: "SampleIndexes", Doc: "SampleIndexes are the current set of \"sample\" unit indexes,\nwhich are a smaller subset of units that represent the behavior\nof the layer, for computationally intensive statistics and displays\n(e.g., PCA, ActRF, NetView rasters), when the layer is large.\nIf none have been set, then all units are used.\nSee utility function CenterPoolIndexes that returns indexes of\nunits in the central pools of a 4D layer."}, {Name: "SampleShape", Doc: "SampleShape is the shape to use for the subset of sample\nunit indexes, in terms of an array of dimensions.\nSee Shape for more info.\nLayers that set SampleIndexes should also set this,\notherwise a 1D array of len SampleIndexes will be used.\nSee utility function CenterPoolShape that returns shape of\nunits in the central pools of a 4D layer."}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.NetParams", IDName: "net-params", Doc: "NetParams handles standard parameters for a Network\n(use econfig and a Config struct for other configuration params).\nAssumes a Set named \"Base\" has the base-level parameters, which are\nalways applied first, followed optionally by additional Set(s)\nthat can have different parameters to try.", Fields: []types.Field{{Name: "Params", Doc: "full collection of param sets to use"}, {Name: "ExtraSheets", Doc: "optional additional sheets of parameters to apply after Base -- can use multiple names separated by spaces (don't put spaces in Sheet names!)"}, {Name: "Tag", Doc: "optional additional tag to add to file names, logs to identify params / run config"}, {Name: "Network", Doc: "the network to apply parameters to"}, {Name: "NetHypers", Doc: "list of hyper parameters compiled from the network parameters, using the layers and pathways from the network, so that the same styling logic as for regular parameters can be used"}, {Name: "SetMsg", Doc: "print out messages for each parameter that is set"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.LaySize", IDName: "lay-size", Doc: "LaySize contains parameters for size of layers", Fields: []types.Field{{Name: "Y", Doc: "Y (vertical) size of layer -- in units for 2D, or number of pools (outer dimension) for 4D layer"}, {Name: "X", Doc: "X (horizontal) size of layer -- in units for 2D, or number of pools (outer dimension) for 4D layer"}, {Name: "PoolY", Doc: "Y (vertical) size of each pool in units, only for 4D layers (inner dimension)"}, {Name: "PoolX", Doc: "Y (horizontal) size of each pool in units, only for 4D layers (inner dimension)"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.NetSize", IDName: "net-size", Doc: "NetSize is a network schema for holding a params for layer sizes.\nValues can be queried for getting sizes when configuring the network.\nUses params.Flex to support flexible parameter specification"})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.Network", IDName: "network", Doc: "Network defines the minimal interface for a neural network,\nused for managing the structural elements of a network,\nand for visualization, I/O, etc.\nMost of the standard expected functionality is defined in the\nNetworkBase struct, and this interface only has methods that must be\nimplemented specifically for a given algorithmic implementation.", Methods: []types.Method{{Name: "AsEmer", Doc: "AsEmer returns the network as an *emer.NetworkBase,\nto access base functionality.", Returns: []string{"NetworkBase"}}, {Name: "Label", Doc: "Label satisfies the core.Labeler interface for getting\nthe name of objects generically.", Returns: []string{"string"}}, {Name: "NumLayers", Doc: "NumLayers returns the number of layers in the network.", Returns: []string{"int"}}, {Name: "EmerLayer", Doc: "EmerLayer returns layer as emer.Layer interface at given index.\nDoes not do extra bounds checking.", Args: []string{"idx"}, Returns: []string{"Layer"}}, {Name: "MaxParallelData", Doc: "MaxParallelData returns the maximum number of data inputs that can be\nprocessed in parallel by the network.\nThe NetView supports display of up to this many data elements.", Returns: []string{"int"}}, {Name: "NParallelData", Doc: "NParallelData returns the current number of data inputs currently being\nprocessed in parallel by the network.\nLogging supports recording each of these where appropriate.", Returns: []string{"int"}}, {Name: "Defaults", Doc: "Defaults sets default parameter values for everything in the Network."}, {Name: "UpdateParams", Doc: "UpdateParams() updates parameter values for all Network parameters,\nbased on any other params that might have changed."}, {Name: "ApplyParams", Doc: "ApplyParams applies given parameter style Sheet to layers\nand paths in this network.\nCalls UpdateParams on anything set to ensure derived parameters\nare all updated.\nIf setMsg is true, then a message is printed to confirm each\nparameter that is set.\nit always prints a message if a parameter fails to be set.\nreturns true if any params were set, and error if there were any errors.", Args: []string{"pars", "setMsg"}, Returns: []string{"bool", "error"}}, {Name: "NonDefaultParams", Doc: "NonDefaultParams returns a listing of all parameters in the Network that\nare not at their default values -- useful for setting param styles etc.", Returns: []string{"string"}}, {Name: "AllParams", Doc: "AllParams returns a listing of all parameters in the Network", Returns: []string{"string"}}, {Name: "KeyLayerParams", Doc: "KeyLayerParams returns a listing for all layers in the network,\nof the most important layer-level params (specific to each algorithm).", Returns: []string{"string"}}, {Name: "KeyPathParams", Doc: "KeyPathParams returns a listing for all Recv pathways in the network,\nof the most important pathway-level params (specific to each algorithm).", Returns: []string{"string"}}, {Name: "UnitVarNames", Doc: "UnitVarNames returns a list of variable names available on\nthe units in this network.\nThis list determines what is shown in the NetView\n(and the order of vars list).\nNot all layers need to support all variables,\nbut must safely return math32.NaN() for unsupported ones.\nThis is typically a global list so do not modify!", Returns: []string{"[]string"}}, {Name: "UnitVarProps", Doc: "UnitVarProps returns a map of unit variable properties,\nwith the key being the name of the variable,\nand the value gives a space-separated list of\ngo-tag-style properties for that variable.\nThe NetView recognizes the following properties:\nrange:\"##\" = +- range around 0 for default display scaling\nmin:\"##\" max:\"##\" = min, max display range\nauto-scale:\"+\" or \"-\" = use automatic scaling instead of fixed range or not.\nzeroctr:\"+\" or \"-\" = control whether zero-centering is used\ndesc:\"txt\" tooltip description of the variable\nNote: this is typically a global list so do not modify!", Returns: []string{"map[string]string"}}, {Name: "SynVarNames", Doc: "SynVarNames returns the names of all the variables\non the synapses in this network.\nThis list determines what is shown in the NetView\n(and the order of vars list).\nNot all pathways need to support all variables,\nbut must safely return math32.NaN() for\nunsupported ones.\nThis is typically a global list so do not modify!", Returns: []string{"[]string"}}, {Name: "SynVarProps", Doc: "SynVarProps returns a map of synapse variable properties,\nwith the key being the name of the variable,\nand the value gives a space-separated list of\ngo-tag-style properties for that variable.\nThe NetView recognizes the following properties:\nrange:\"##\" = +- range around 0 for default display scaling\nmin:\"##\" max:\"##\" = min, max display range\nauto-scale:\"+\" or \"-\" = use automatic scaling instead of fixed range or not.\nzeroctr:\"+\" or \"-\" = control whether zero-centering is used\nNote: this is typically a global list so do not modify!", Returns: []string{"map[string]string"}}, {Name: "WriteWtsJSON", Doc: "WriteWtsJSON writes network weights (and any other state\nthat adapts with learning) to JSON-formatted output.", Args: []string{"w"}, Returns: []string{"error"}}, {Name: "ReadWtsJSON", Doc: "ReadWtsJSON reads network weights (and any other state\nthat adapts with learning) from JSON-formatted input.\nReads into a temporary weights.Network structure that\nis then passed to SetWts to actually set the weights.", Args: []string{"r"}, Returns: []string{"error"}}, {Name: "SetWts", Doc: "SetWts sets the weights for this network from weights.Network\ndecoded values.", Args: []string{"nw"}, Returns: []string{"error"}}, {Name: "SaveWtsJSON", Doc: "SaveWtsJSON saves network weights (and any other state\nthat adapts with learning) to a JSON-formatted file.\nIf filename has .gz extension, then file is gzip compressed.", Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "OpenWtsJSON", Doc: "OpenWtsJSON opens network weights (and any other state that\nadapts with learning) from a JSON-formatted file.\nIf filename has .gz extension, then file is gzip uncompressed.", Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "VarRange", Doc: "VarRange returns the min / max values for given variable", Args: []string{"varNm"}, Returns: []string{"min", "max", "err"}}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.NetworkBase", IDName: "network-base", Doc: "NetworkBase defines the basic data for a neural network,\nused for managing the structural elements of a network,\nand for visualization, I/O, etc.", Fields: []types.Field{{Name: "EmerNetwork", Doc: "EmerNetwork provides access to the emer.Network interface\nmethods for functions defined in the NetworkBase type.\nMust set this with a pointer to the actual instance\nwhen created, using InitNetwork function."}, {Name: "Name", Doc: "overall name of network, which helps discriminate if there are multiple."}, {Name: "WeightsFile", Doc: "filename of last weights file loaded or saved."}, {Name: "LayerNameMap", Doc: "map of name to layers, for EmerLayerByName methods"}, {Name: "LayerClassMap", Doc: "map from class name to layer names."}, {Name: "MinPos", Doc: "minimum display position in network"}, {Name: "MaxPos", Doc: "maximum display position in network"}, {Name: "MetaData", Doc: "optional metadata that is saved in network weights files,\ne.g., can indicate number of epochs that were trained,\nor any other information about this network that would be useful to save."}, {Name: "Rand", Doc: "random number generator for the network.\nall random calls must use this.\nSet seed here for weight initialization values."}, {Name: "RandSeed", Doc: "Random seed to be set at the start of configuring\nthe network and initializing the weights.\nSet this to get a different set of weights."}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.Path", IDName: "path", Doc: "Path defines the minimal interface for a pathway\nwhich connects two layers, using a specific Pattern\nof connectivity, and with its own set of parameters.\nThis supports visualization (NetView), I/O,\nand parameter setting functionality provided by emergent.\nMost of the standard expected functionality is defined in the\nPathBase struct, and this interface only has methods that must be\nimplemented specifically for a given algorithmic implementation,", Methods: []types.Method{{Name: "AsEmer", Doc: "AsEmer returns the path as an *emer.PathBase,\nto access base functionality.", Returns: []string{"PathBase"}}, {Name: "Label", Doc: "Label satisfies the core.Labeler interface for getting\nthe name of objects generically.", Returns: []string{"string"}}, {Name: "TypeName", Doc: "TypeName is the type or category of path, defined\nby the algorithm (and usually set by an enum).", Returns: []string{"string"}}, {Name: "SendLayer", Doc: "SendLayer returns the sending layer for this pathway,\nas an emer.Layer interface.  The actual Path implmenetation\ncan use a Send field with the actual Layer struct type.", Returns: []string{"Layer"}}, {Name: "RecvLayer", Doc: "RecvLayer returns the receiving layer for this pathway,\nas an emer.Layer interface.  The actual Path implmenetation\ncan use a Recv field with the actual Layer struct type.", Returns: []string{"Layer"}}, {Name: "NumSyns", Doc: "NumSyns returns the number of synapses for this path.\nThis is the max idx for SynValue1D and the number\nof vals set by SynValues.", Returns: []string{"int"}}, {Name: "SynIndex", Doc: "SynIndex returns the index of the synapse between given send, recv unit indexes\n(1D, flat indexes). Returns -1 if synapse not found between these two neurons.\nThis requires searching within connections for receiving unit (a bit slow).", Args: []string{"sidx", "ridx"}, Returns: []string{"int"}}, {Name: "SynVarNames", Doc: "SynVarNames returns the names of all the variables on the synapse\nThis is typically a global list so do not modify!", Returns: []string{"[]string"}}, {Name: "SynVarNum", Doc: "SynVarNum returns the number of synapse-level variables\nfor this paths.  This is needed for extending indexes in derived types.", Returns: []string{"int"}}, {Name: "SynVarIndex", Doc: "SynVarIndex returns the index of given variable within the synapse,\naccording to *this path's* SynVarNames() list (using a map to lookup index),\nor -1 and error message if not found.", Args: []string{"varNm"}, Returns: []string{"int", "error"}}, {Name: "SynValues", Doc: "SynValues sets values of given variable name for each synapse,\nusing the natural ordering of the synapses (sender based for Axon),\ninto given float32 slice (only resized if not big enough).\nReturns error on invalid var name.", Args: []string{"vals", "varNm"}, Returns: []string{"error"}}, {Name: "SynValue1D", Doc: "SynValue1D returns value of given variable index\n(from SynVarIndex) on given SynIndex.\nReturns NaN on invalid index.\nThis is the core synapse var access method used by other methods,\nso it is the only one that needs to be updated for derived types.", Args: []string{"varIndex", "synIndex"}, Returns: []string{"float32"}}, {Name: "UpdateParams", Doc: "UpdateParams() updates parameter values for all Path parameters,\nbased on any other params that might have changed."}, {Name: "ApplyParams", Doc: "ApplyParams applies given parameter style Sheet to this pathway.\nCalls UpdateParams if anything set to ensure derived\nparameters are all updated.\nIf setMsg is true, then a message is printed to confirm each\nparameter that is set.\nIt always prints a message if a parameter fails to be set.\nreturns true if any params were set, and error if there were any errors.", Args: []string{"pars", "setMsg"}, Returns: []string{"bool", "error"}}, {Name: "SetParam", Doc: "SetParam sets parameter at given path to given value.\nreturns error if path not found or value cannot be set.", Args: []string{"path", "val"}, Returns: []string{"error"}}, {Name: "NonDefaultParams", Doc: "NonDefaultParams returns a listing of all parameters in the Pathway that\nare not at their default values -- useful for setting param styles etc.", Returns: []string{"string"}}, {Name: "AllParams", Doc: "AllParams returns a listing of all parameters in the Pathway.", Returns: []string{"string"}}, {Name: "WriteWtsJSON", Doc: "WriteWtsJSON writes the weights from this pathway\nfrom the receiver-side perspective in a JSON text format.\nWe build in the indentation logic to make it much faster and\nmore efficient.", Args: []string{"w", "depth"}}, {Name: "ReadWtsJSON", Doc: "ReadWtsJSON reads the weights from this pathway\nfrom the receiver-side perspective in a JSON text format.\nThis is for a set of weights that were saved *for one path only*\nand is not used for the network-level ReadWtsJSON,\nwhich reads into a separate structure -- see SetWts method.", Args: []string{"r"}, Returns: []string{"error"}}, {Name: "SetWts", Doc: "SetWts sets the weights for this pathway from weights.Path\ndecoded values", Args: []string{"pw"}, Returns: []string{"error"}}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.PathBase", IDName: "path-base", Doc: "PathBase defines the basic shared data for a pathway\nwhich connects two layers, using a specific Pattern\nof connectivity, and with its own set of parameters.\nName is set automatically to:\nNothing algorithm-specific is implemented here.", Fields: []types.Field{{Name: "EmerPath", Doc: "EmerPath provides access to the emer.Path interface\nmethods for functions defined in the PathBase type.\nMust set this with a pointer to the actual instance\nwhen created, using InitPath function."}, {Name: "Name", Doc: "Name of the path, which can be automatically set to\nSendLayer().Name + \"To\" + RecvLayer().Name via\nSetStandardName method."}, {Name: "Class", Doc: "Class is for applying parameter styles across multiple paths\nthat all get the same parameters.  This can be space separated\nwith multple classes."}, {Name: "Pattern", Doc: "Pattern specifies the pattern of connectivity\nfor interconnecting the sending and receiving layers."}}})

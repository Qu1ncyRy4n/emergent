// Code generated by "core generate -add-types"; DO NOT EDIT.

package emer

import (
	"cogentcore.org/core/types"
)

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.Layer", IDName: "layer", Doc: "Layer defines the basic interface for neural network layers, used for managing the structural\nelements of a network, and for visualization, I/O, etc.\nInterfaces are automatically pointers -- think of this as a pointer to your specific layer\ntype, with a very basic interface for accessing general structural properties.  Nothing\nalgorithm-specific is implemented here -- all of that goes in your specific layer struct.", Methods: []types.Method{{Name: "InitName", Doc: "InitName MUST be called to initialize the layer's pointer to itself as an emer.Layer\nwhich enables the proper interface methods to be called.  Also sets the name, and\nthe parent network that this layer belongs to (which layers may want to retain).", Args: []string{"lay", "name", "net"}}, {Name: "Label", Doc: "Label satisfies the core.Labeler interface for getting the name of objects generically", Returns: []string{"string"}}, {Name: "SetName", Doc: "SetName sets name of layer", Args: []string{"nm"}}, {Name: "AddClass", Doc: "AddClass adds a CSS-style class name(s) for this layer,\nensuring that it is not a duplicate, and properly space separated.\nReturns Layer so it can be chained to set other properties too", Args: []string{"cls"}, Returns: []string{"Layer"}}, {Name: "IsOff", Doc: "IsOff returns true if layer has been turned Off (lesioned) -- for experimentation", Returns: []string{"bool"}}, {Name: "SetOff", Doc: "SetOff sets the \"off\" (lesioned) status of layer. Also sets the Off state of all\npathways from this layer to other layers.", Args: []string{"off"}}, {Name: "Shape", Doc: "Shape returns the organization of units in the layer, in terms of an array of dimensions.\nRow-major ordering is default (Y then X), outer-most to inner-most.\nif 2D, then it is a simple Y,X layer with no sub-structure (pools).\nIf 4D, then it number of pools Y, X and then number of units per pool Y, X", Returns: []string{"Shape"}}, {Name: "Is2D", Doc: "Is2D() returns true if this is a 2D layer (no Pools)", Returns: []string{"bool"}}, {Name: "Is4D", Doc: "Is4D() returns true if this is a 4D layer (has Pools as inner 2 dimensions)", Returns: []string{"bool"}}, {Name: "Index4DFrom2D", Doc: "Index4DFrom2D returns the 4D index from 2D coordinates\nwithin which inner dims are interleaved.  Returns false if 2D coords are invalid.", Args: []string{"x", "y"}, Returns: []string{"[]int", "bool"}}, {Name: "Type", Doc: "Type returns the functional type of layer according to LayerType (extensible in\nmore specialized algorithms)", Returns: []string{"LayerType"}}, {Name: "SetType", Doc: "SetType sets the functional type of layer", Args: []string{"typ"}}, {Name: "Config", Doc: "Config configures the basic parameters of the layer", Args: []string{"shape", "typ"}}, {Name: "RelPos", Doc: "RelPos returns the relative 3D position specification for this layer\nfor display in the 3D NetView -- see Pos() for display conventions.", Returns: []string{"Rel"}}, {Name: "SetRelPos", Doc: "SetRelPos sets the the relative 3D position specification for this layer", Args: []string{"r"}}, {Name: "Pos", Doc: "Pos returns the 3D position of the lower-left-hand corner of the layer.\nThe 3D view has layers arranged in X-Y planes stacked vertically along the Z axis.\nSomewhat confusingly, this differs from the standard 3D graphics convention,\nwhere the vertical dimension is Y and Z is the depth dimension.  However, in the\nmore \"layer-centric\" way of thinking about it, it is natural for the width & height\nto map onto X and Y, and then Z is left over for stacking vertically.", Returns: []string{"Vector3"}}, {Name: "SetPos", Doc: "SetPos sets the 3D position of this layer -- will generally be overwritten by\nautomatic RelPos setting, unless that doesn't specify a valid relative position.", Args: []string{"pos"}}, {Name: "Size", Doc: "Size returns the display size of this layer for the 3D view -- see Pos() for general info.\nThis is multiplied by the RelPos.Scale factor to rescale layer sizes, and takes\ninto account 2D and 4D layer structures.", Returns: []string{"Vector2"}}, {Name: "Index", Doc: "Index returns a 0..n-1 index of the position of the layer within list of layers\nin the network.  For backprop networks, index position has computational significance.\nFor Leabra networks, it only has significance in determining who gets which weights for\nenforcing initial weight symmetry -- higher layers get weights from lower layers.", Returns: []string{"int"}}, {Name: "SetIndex", Doc: "SetIndex sets the layer index", Args: []string{"idx"}}, {Name: "UnitVarNames", Doc: "UnitVarNames returns a list of variable names available on the units in this layer.\nThis is typically a global list so do not modify!", Returns: []string{"[]string"}}, {Name: "UnitVarProps", Doc: "UnitVarProps returns a map of unit variable properties, with the key being the\nname of the variable, and the value gives a space-separated list of\ngo-tag-style properties for that variable.\nThe NetView recognizes the following properties:\nrange:\"##\" = +- range around 0 for default display scaling\nmin:\"##\" max:\"##\" = min, max display range\nauto-scale:\"+\" or \"-\" = use automatic scaling instead of fixed range or not.\nzeroctr:\"+\" or \"-\" = control whether zero-centering is used\ndesc:\"txt\" tooltip description of the variable\nNote: this is a global list so do not modify!", Returns: []string{"map[string]string"}}, {Name: "UnitVarIndex", Doc: "UnitVarIndex returns the index of given variable within the Neuron,\naccording to *this layer's* UnitVarNames() list (using a map to lookup index),\nor -1 and error message if not found.", Args: []string{"varNm"}, Returns: []string{"int", "error"}}, {Name: "UnitVarNum", Doc: "UnitVarNum returns the number of Neuron-level variables\nfor this layer.  This is needed for extending indexes in derived types.", Returns: []string{"int"}}, {Name: "UnitVal1D", Doc: "UnitVal1D returns value of given variable index on given unit,\nusing 1-dimensional index, and a data parallel index di,\nfor networks capable of processing multiple input patterns in parallel.\nreturns NaN on invalid index.\nThis is the core unit var access method used by other methods,\nso it is the only one that needs to be updated for derived layer types.", Args: []string{"varIndex", "idx", "di"}, Returns: []string{"float32"}}, {Name: "UnitValues", Doc: "UnitValues fills in values of given variable name on unit,\nfor each unit in the layer, into given float32 slice (only resized if not big enough).\ndi is a data parallel index di, for networks capable of processing input patterns in parallel.\nReturns error on invalid var name.", Args: []string{"vals", "varNm", "di"}, Returns: []string{"error"}}, {Name: "UnitValuesTensor", Doc: "UnitValuesTensor fills in values of given variable name on unit\nfor each unit in the layer, into given tensor.\ndi is a data parallel index di, for networks capable of processing input patterns in parallel.\nIf tensor is not already big enough to hold the values, it is\nset to the same shape as the layer.\nReturns error on invalid var name.", Args: []string{"tsr", "varNm", "di"}, Returns: []string{"error"}}, {Name: "UnitValuesRepTensor", Doc: "UnitValuesRepTensor fills in values of given variable name on unit\nfor a smaller subset of representative units in the layer, into given tensor.\ndi is a data parallel index di, for networks capable of processing input patterns in parallel.\nThis is used for computationally intensive stats or displays that work\nmuch better with a smaller number of units.\nThe set of representative units are defined by SetRepIndexes -- all units\nare used if no such subset has been defined.\nIf tensor is not already big enough to hold the values, it is\nset to RepShape to hold all the values if subset is defined,\notherwise it calls UnitValuesTensor and is identical to that.\nReturns error on invalid var name.", Args: []string{"tsr", "varNm", "di"}, Returns: []string{"error"}}, {Name: "RepIndexes", Doc: "RepIndexes returns the current set of representative unit indexes.\nwhich are a smaller subset of units that represent the behavior\nof the layer, for computationally intensive statistics and displays\n(e.g., PCA, ActRF, NetView rasters).\nReturns nil if none has been set (in which case all units should be used).\nSee utility function CenterPoolIndexes that returns indexes of\nunits in the central pools of a 4D layer.", Returns: []string{"[]int"}}, {Name: "RepShape", Doc: "RepShape returns the shape to use for the subset of representative\nunit indexes, in terms of an array of dimensions.  See Shape() for more info.\nLayers that set RepIndexes should also set this, otherwise a 1D array\nof len RepIndexes will be used.\nSee utility function CenterPoolShape that returns shape of\nunits in the central pools of a 4D layer.", Returns: []string{"Shape"}}, {Name: "SetRepIndexesShape", Doc: "SetRepIndexesShape sets the RepIndexes, and RepShape and as list of dimension sizes", Args: []string{"idxs", "shape"}}, {Name: "UnitValue", Doc: "UnitVal returns value of given variable name on given unit,\nusing shape-based dimensional index.\nReturns NaN on invalid var name or index.\ndi is a data parallel index di, for networks capable of processing input patterns in parallel.", Args: []string{"varNm", "idx", "di"}, Returns: []string{"float32"}}, {Name: "NRecvPaths", Doc: "NRecvPaths returns the number of receiving pathways", Returns: []string{"int"}}, {Name: "RecvPath", Doc: "RecvPath returns a specific receiving pathway", Args: []string{"idx"}, Returns: []string{"Path"}}, {Name: "NSendPaths", Doc: "NSendPaths returns the number of sending pathways", Returns: []string{"int"}}, {Name: "SendPath", Doc: "SendPath returns a specific sending pathway", Args: []string{"idx"}, Returns: []string{"Path"}}, {Name: "SendNameTry", Doc: "SendNameTry looks for a pathway connected to this layer whose sender layer has a given name", Args: []string{"sender"}, Returns: []string{"Path", "error"}}, {Name: "SendNameTypeTry", Doc: "SendNameTypeTry looks for a pathway connected to this layer whose sender layer has a given name and type", Args: []string{"sender", "typ"}, Returns: []string{"Path", "error"}}, {Name: "RecvNameTry", Doc: "RecvNameTry looks for a pathway connected to this layer whose receiver layer has a given name", Args: []string{"recv"}, Returns: []string{"Path", "error"}}, {Name: "RecvNameTypeTry", Doc: "RecvNameTypeTry looks for a pathway connected to this layer whose receiver layer has a given name and type", Args: []string{"recv", "typ"}, Returns: []string{"Path", "error"}}, {Name: "RecvPathValues", Doc: "RecvPathValues fills in values of given synapse variable name,\nfor pathway from given sending layer and neuron 1D index,\nfor all receiving neurons in this layer,\ninto given float32 slice (only resized if not big enough).\npathType is the string representation of the path type -- used if non-empty,\nuseful when there are multiple pathways between two layers.\nReturns error on invalid var name.\nIf the receiving neuron is not connected to the given sending layer or neuron\nthen the value is set to math32.NaN().\nReturns error on invalid var name or lack of recv path (vals always set to nan on path err).", Args: []string{"vals", "varNm", "sendLay", "sendIndex1D", "pathType"}, Returns: []string{"error"}}, {Name: "SendPathValues", Doc: "SendPathValues fills in values of given synapse variable name,\nfor pathway into given receiving layer and neuron 1D index,\nfor all sending neurons in this layer,\ninto given float32 slice (only resized if not big enough).\npathType is the string representation of the path type -- used if non-empty,\nuseful when there are multiple pathways between two layers.\nReturns error on invalid var name.\nIf the sending neuron is not connected to the given receiving layer or neuron\nthen the value is set to math32.NaN().\nReturns error on invalid var name or lack of recv path (vals always set to nan on path err).", Args: []string{"vals", "varNm", "recvLay", "recvIndex1D", "pathType"}, Returns: []string{"error"}}, {Name: "Defaults", Doc: "Defaults sets default parameter values for all Layer and recv pathway parameters"}, {Name: "UpdateParams", Doc: "UpdateParams() updates parameter values for all Layer and recv pathway parameters,\nbased on any other params that might have changed."}, {Name: "ApplyParams", Doc: "ApplyParams applies given parameter style Sheet to this layer and its recv pathways.\nCalls UpdateParams on anything set to ensure derived parameters are all updated.\nIf setMsg is true, then a message is printed to confirm each parameter that is set.\nit always prints a message if a parameter fails to be set.\nreturns true if any params were set, and error if there were any errors.", Args: []string{"pars", "setMsg"}, Returns: []string{"bool", "error"}}, {Name: "SetParam", Doc: "SetParam sets parameter at given path to given value.\nreturns error if path not found or value cannot be set.", Args: []string{"path", "val"}, Returns: []string{"error"}}, {Name: "NonDefaultParams", Doc: "NonDefaultParams returns a listing of all parameters in the Layer that\nare not at their default values -- useful for setting param styles etc.", Returns: []string{"string"}}, {Name: "AllParams", Doc: "AllParams returns a listing of all parameters in the Layer", Returns: []string{"string"}}, {Name: "WriteWtsJSON", Doc: "WriteWtsJSON writes the weights from this layer from the receiver-side perspective\nin a JSON text format.  We build in the indentation logic to make it much faster and\nmore efficient.", Args: []string{"w", "depth"}}, {Name: "ReadWtsJSON", Doc: "ReadWtsJSON reads the weights from this layer from the receiver-side perspective\nin a JSON text format.  This is for a set of weights that were saved *for one layer only*\nand is not used for the network-level ReadWtsJSON, which reads into a separate\nstructure -- see SetWts method.", Args: []string{"r"}, Returns: []string{"error"}}, {Name: "SetWts", Doc: "SetWts sets the weights for this layer from weights.Layer decoded values", Args: []string{"lw"}, Returns: []string{"error"}}, {Name: "Build", Doc: "Build constructs the layer and pathway state based on the layer shapes\nand patterns of interconnectivity", Returns: []string{"error"}}, {Name: "VarRange", Doc: "VarRange returns the min / max values for given variable\nover the layer", Args: []string{"varNm"}, Returns: []string{"min", "max", "err"}}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.Layers", IDName: "layers", Doc: "Layers is a slice of layers"})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.LayerType", IDName: "layer-type", Doc: "LayerType is the type of the layer: Input, Hidden, Target, Compare.\nClass parameter styles automatically key off of these types.\nSpecialized algorithms can extend this to other types, but these types encompass\nmost standard neural network models."})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.LayNames", IDName: "lay-names", Doc: "LayNames is a list of layer names.\nHas convenience methods for adding, validating."})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.NetParams", IDName: "net-params", Doc: "NetParams handles standard parameters for a Network only\n(use econfig and a Config struct for other configuration params)\nAssumes a Set named \"Base\" has the base-level parameters, which are\nalways applied first, followed optionally by additional Set(s)\nthat can have different parameters to try.", Fields: []types.Field{{Name: "Params", Doc: "full collection of param sets to use"}, {Name: "ExtraSheets", Doc: "optional additional sheets of parameters to apply after Base -- can use multiple names separated by spaces (don't put spaces in Sheet names!)"}, {Name: "Tag", Doc: "optional additional tag to add to file names, logs to identify params / run config"}, {Name: "Network", Doc: "the network to apply parameters to"}, {Name: "NetHypers", Doc: "list of hyper parameters compiled from the network parameters, using the layers and pathways from the network, so that the same styling logic as for regular parameters can be used"}, {Name: "SetMsg", Doc: "print out messages for each parameter that is set"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.LaySize", IDName: "lay-size", Doc: "LaySize contains parameters for size of layers", Fields: []types.Field{{Name: "Y", Doc: "Y (vertical) size of layer -- in units for 2D, or number of pools (outer dimension) for 4D layer"}, {Name: "X", Doc: "X (horizontal) size of layer -- in units for 2D, or number of pools (outer dimension) for 4D layer"}, {Name: "PoolY", Doc: "Y (vertical) size of each pool in units, only for 4D layers (inner dimension)"}, {Name: "PoolX", Doc: "Y (horizontal) size of each pool in units, only for 4D layers (inner dimension)"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.NetSize", IDName: "net-size", Doc: "NetSize is a network schema for holding a params for layer sizes.\nValues can be queried for getting sizes when configuring the network.\nUses params.Flex to support flexible parameter specification"})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.Network", IDName: "network", Doc: "Network defines the basic interface for a neural network, used for managing the structural\nelements of a network, and for visualization, I/O, etc", Methods: []types.Method{{Name: "InitName", Doc: "InitName MUST be called to initialize the network's pointer to itself as an emer.Network\nwhich enables the proper interface methods to be called.  Also sets the name.", Args: []string{"net", "name"}}, {Name: "Name", Doc: "Name() returns name of the network", Returns: []string{"string"}}, {Name: "Label", Doc: "Label satisfies the core.Labeler interface for getting the name of objects generically", Returns: []string{"string"}}, {Name: "NLayers", Doc: "NLayers returns the number of layers in the network", Returns: []string{"int"}}, {Name: "Layer", Doc: "Layer returns layer (as emer.Layer interface) at given index -- does not\ndo extra bounds checking", Args: []string{"idx"}, Returns: []string{"Layer"}}, {Name: "LayerByName", Doc: "LayerByName returns layer of given name, nil if not found.\nLayer names must be unique and a map is used so this is a fast operation", Args: []string{"name"}, Returns: []string{"Layer"}}, {Name: "LayerByNameTry", Doc: "LayerByNameTry returns layer of given name, returns error if not found.\nLayer names must be unique and a map is used so this is a fast operation", Args: []string{"name"}, Returns: []string{"Layer", "error"}}, {Name: "PathByNameTry", Doc: "PathByNameTry returns path of given name, returns error if not found.\nPath names are SendToRecv, and are looked up by parsing the name", Args: []string{"name"}, Returns: []string{"Path", "error"}}, {Name: "Defaults", Doc: "Defaults sets default parameter values for everything in the Network"}, {Name: "UpdateParams", Doc: "UpdateParams() updates parameter values for all Network parameters,\nbased on any other params that might have changed."}, {Name: "ApplyParams", Doc: "ApplyParams applies given parameter style Sheet to layers and paths in this network.\nCalls UpdateParams on anything set to ensure derived parameters are all updated.\nIf setMsg is true, then a message is printed to confirm each parameter that is set.\nit always prints a message if a parameter fails to be set.\nreturns true if any params were set, and error if there were any errors.", Args: []string{"pars", "setMsg"}, Returns: []string{"bool", "error"}}, {Name: "NonDefaultParams", Doc: "NonDefaultParams returns a listing of all parameters in the Network that\nare not at their default values -- useful for setting param styles etc.", Returns: []string{"string"}}, {Name: "AllParams", Doc: "AllParams returns a listing of all parameters in the Network", Returns: []string{"string"}}, {Name: "KeyLayerParams", Doc: "KeyLayerParams returns a listing for all layers in the network,\nof the most important layer-level params (specific to each algorithm).", Returns: []string{"string"}}, {Name: "KeyPathParams", Doc: "KeyPathParams returns a listing for all Recv pathways in the network,\nof the most important pathway-level params (specific to each algorithm).", Returns: []string{"string"}}, {Name: "UnitVarNames", Doc: "UnitVarNames returns a list of variable names available on the units in this network.\nThis list determines what is shown in the NetView (and the order of vars list).\nNot all layers need to support all variables, but must safely return math32.NaN() for\nunsupported ones.\nThis is typically a global list so do not modify!", Returns: []string{"[]string"}}, {Name: "UnitVarProps", Doc: "UnitVarProps returns a map of unit variable properties, with the key being the\nname of the variable, and the value gives a space-separated list of\ngo-tag-style properties for that variable.\nThe NetView recognizes the following properties:\nrange:\"##\" = +- range around 0 for default display scaling\nmin:\"##\" max:\"##\" = min, max display range\nauto-scale:\"+\" or \"-\" = use automatic scaling instead of fixed range or not.\nzeroctr:\"+\" or \"-\" = control whether zero-centering is used\ndesc:\"txt\" tooltip description of the variable\nNote: this is typically a global list so do not modify!", Returns: []string{"map[string]string"}}, {Name: "SynVarNames", Doc: "SynVarNames returns the names of all the variables on the synapses in this network.\nThis list determines what is shown in the NetView (and the order of vars list).\nNot all pathways need to support all variables, but must safely return math32.NaN() for\nunsupported ones.\nThis is typically a global list so do not modify!", Returns: []string{"[]string"}}, {Name: "SynVarProps", Doc: "SynVarProps returns a map of synapse variable properties, with the key being the\nname of the variable, and the value gives a space-separated list of\ngo-tag-style properties for that variable.\nThe NetView recognizes the following properties:\nrange:\"##\" = +- range around 0 for default display scaling\nmin:\"##\" max:\"##\" = min, max display range\nauto-scale:\"+\" or \"-\" = use automatic scaling instead of fixed range or not.\nzeroctr:\"+\" or \"-\" = control whether zero-centering is used\nNote: this is typically a global list so do not modify!", Returns: []string{"map[string]string"}}, {Name: "WriteWtsJSON", Doc: "WriteWtsJSON writes network weights (and any other state that adapts with learning)\nto JSON-formatted output.", Args: []string{"w"}, Returns: []string{"error"}}, {Name: "ReadWtsJSON", Doc: "ReadWtsJSON reads network weights (and any other state that adapts with learning)\nfrom JSON-formatted input.  Reads into a temporary weights.Network structure that\nis then passed to SetWts to actually set the weights.", Args: []string{"r"}, Returns: []string{"error"}}, {Name: "SetWts", Doc: "SetWts sets the weights for this network from weights.Network decoded values", Args: []string{"nw"}, Returns: []string{"error"}}, {Name: "SaveWtsJSON", Doc: "SaveWtsJSON saves network weights (and any other state that adapts with learning)\nto a JSON-formatted file.  If filename has .gz extension, then file is gzip compressed.", Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "OpenWtsJSON", Doc: "OpenWtsJSON opens network weights (and any other state that adapts with learning)\nfrom a JSON-formatted file.  If filename has .gz extension, then file is gzip uncompressed.", Args: []string{"filename"}, Returns: []string{"error"}}, {Name: "Bounds", Doc: "Bounds returns the minimum and maximum display coordinates of the network for 3D display", Returns: []string{"min", "max"}}, {Name: "VarRange", Doc: "VarRange returns the min / max values for given variable", Args: []string{"varNm"}, Returns: []string{"min", "max", "err"}}, {Name: "LayersByClass", Doc: "LayersByClass returns a list of layer names by given class(es).\nLists are compiled when network Build() function called.\nThe layer Type is always included as a Class, along with any other\nspace-separated strings specified in Class for parameter styling, etc.\nIf no classes are passed, all layer names in order are returned.", Args: []string{"classes"}, Returns: []string{"[]string"}}, {Name: "MaxParallelData", Doc: "MaxParallelData returns the maximum number of data inputs that can be\nprocessed in parallel by the network.\nThe NetView supports display of up to this many data elements.", Returns: []string{"int"}}, {Name: "NParallelData", Doc: "NParallelData returns the current number of data inputs currently being\nprocessed in parallel by the network.\nLogging supports recording each of these where appropriate.", Returns: []string{"int"}}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.Params", IDName: "params", Doc: "Params handles standard parameters for a Network and other objects.\nAssumes a Set named \"Base\" has the base-level parameters, which are\nalways applied first, followed optionally by additional Set(s)\nthat can have different parameters to try.", Fields: []types.Field{{Name: "Params", Doc: "full collection of param sets to use"}, {Name: "ExtraSets", Doc: "optional additional set(s) of parameters to apply after Base -- can use multiple names separated by spaces (don't put spaces in Set names!)"}, {Name: "Tag", Doc: "optional additional tag to add to file names, logs to identify params / run config"}, {Name: "Objects", Doc: "map of objects to apply parameters to -- the key is the name of the Sheet for each object, e.g.,"}, {Name: "NetHypers", Doc: "list of hyper parameters compiled from the network parameters, using the layers and pathways from the network, so that the same styling logic as for regular parameters can be used"}, {Name: "SetMsg", Doc: "print out messages for each parameter that is set"}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.Path", IDName: "path", Doc: "Path defines the basic interface for a pathway which connects two layers.\nName is set automatically to: SendLay().Name() + \"To\" + RecvLay().Name()", Methods: []types.Method{{Name: "Init", Doc: "Init MUST be called to initialize the path's pointer to itself as an emer.Path\nwhich enables the proper interface methods to be called.", Args: []string{"path"}}, {Name: "SendLay", Doc: "SendLay returns the sending layer for this pathway", Returns: []string{"Layer"}}, {Name: "RecvLay", Doc: "RecvLay returns the receiving layer for this pathway", Returns: []string{"Layer"}}, {Name: "Pattern", Doc: "Pattern returns the pattern of connectivity for interconnecting the layers", Returns: []string{"Pattern"}}, {Name: "SetPattern", Doc: "SetPattern sets the pattern of connectivity for interconnecting the layers.\nReturns Path so it can be chained to set other properties too", Args: []string{"pat"}, Returns: []string{"Path"}}, {Name: "Type", Doc: "Type returns the functional type of pathway according to PathType (extensible in\nmore specialized algorithms)", Returns: []string{"PathType"}}, {Name: "SetType", Doc: "SetType sets the functional type of pathway according to PathType\nReturns Path so it can be chained to set other properties too", Args: []string{"typ"}, Returns: []string{"Path"}}, {Name: "PathTypeName", Doc: "PathTypeName returns the string rep of functional type of pathway\naccording to PathType (extensible in more specialized algorithms, by\nredefining this method as needed).", Returns: []string{"string"}}, {Name: "AddClass", Doc: "AddClass adds a CSS-style class name(s) for this path,\nensuring that it is not a duplicate, and properly space separated.\nReturns Path so it can be chained to set other properties too", Args: []string{"cls"}, Returns: []string{"Path"}}, {Name: "Label", Doc: "Label satisfies the core.Labeler interface for getting the name of objects generically", Returns: []string{"string"}}, {Name: "IsOff", Doc: "IsOff returns true if pathway or either send or recv layer has been turned Off.\nUseful for experimentation", Returns: []string{"bool"}}, {Name: "SetOff", Doc: "SetOff sets the pathway Off status (i.e., lesioned). Careful: Layer.SetOff(true) will\nreactivate that layer's pathways, so pathway-level lesioning should always be called\nafter layer-level lesioning.", Args: []string{"off"}}, {Name: "SynVarNames", Doc: "SynVarNames returns the names of all the variables on the synapse\nThis is typically a global list so do not modify!", Returns: []string{"[]string"}}, {Name: "SynVarProps", Doc: "SynVarProps returns a map of synapse variable properties, with the key being the\nname of the variable, and the value gives a space-separated list of\ngo-tag-style properties for that variable.\nThe NetView recognizes the following properties:\nrange:\"##\" = +- range around 0 for default display scaling\nmin:\"##\" max:\"##\" = min, max display range\nauto-scale:\"+\" or \"-\" = use automatic scaling instead of fixed range or not.\nzeroctr:\"+\" or \"-\" = control whether zero-centering is used\nNote: this is a global list so do not modify!", Returns: []string{"map[string]string"}}, {Name: "SynIndex", Doc: "SynIndex returns the index of the synapse between given send, recv unit indexes\n(1D, flat indexes). Returns -1 if synapse not found between these two neurons.\nThis requires searching within connections for receiving unit (a bit slow).", Args: []string{"sidx", "ridx"}, Returns: []string{"int"}}, {Name: "SynVarIndex", Doc: "SynVarIndex returns the index of given variable within the synapse,\naccording to *this path's* SynVarNames() list (using a map to lookup index),\nor -1 and error message if not found.", Args: []string{"varNm"}, Returns: []string{"int", "error"}}, {Name: "SynVarNum", Doc: "SynVarNum returns the number of synapse-level variables\nfor this paths.  This is needed for extending indexes in derived types.", Returns: []string{"int"}}, {Name: "Syn1DNum", Doc: "Syn1DNum returns the number of synapses for this path as a 1D array.\nThis is the max idx for SynVal1D and the number of vals set by SynValues.", Returns: []string{"int"}}, {Name: "SynVal1D", Doc: "SynVal1D returns value of given variable index (from SynVarIndex) on given SynIndex.\nReturns NaN on invalid index.\nThis is the core synapse var access method used by other methods,\nso it is the only one that needs to be updated for derived layer types.", Args: []string{"varIndex", "synIndex"}, Returns: []string{"float32"}}, {Name: "SynValues", Doc: "SynValues sets values of given variable name for each synapse, using the natural ordering\nof the synapses (sender based for Leabra),\ninto given float32 slice (only resized if not big enough).\nReturns error on invalid var name.", Args: []string{"vals", "varNm"}, Returns: []string{"error"}}, {Name: "SynValue", Doc: "SynVal returns value of given variable name on the synapse\nbetween given send, recv unit indexes (1D, flat indexes).\nReturns math32.NaN() for access errors.", Args: []string{"varNm", "sidx", "ridx"}, Returns: []string{"float32"}}, {Name: "SetSynValue", Doc: "SetSynVal sets value of given variable name on the synapse\nbetween given send, recv unit indexes (1D, flat indexes).\nTypically only supports base synapse variables and is not extended\nfor derived types.\nReturns error for access errors.", Args: []string{"varNm", "sidx", "ridx", "val"}, Returns: []string{"error"}}, {Name: "Defaults", Doc: "Defaults sets default parameter values for all Path parameters"}, {Name: "UpdateParams", Doc: "UpdateParams() updates parameter values for all Path parameters,\nbased on any other params that might have changed."}, {Name: "ApplyParams", Doc: "ApplyParams applies given parameter style Sheet to this pathway.\nCalls UpdateParams if anything set to ensure derived parameters are all updated.\nIf setMsg is true, then a message is printed to confirm each parameter that is set.\nit always prints a message if a parameter fails to be set.\nreturns true if any params were set, and error if there were any errors.", Args: []string{"pars", "setMsg"}, Returns: []string{"bool", "error"}}, {Name: "SetParam", Doc: "SetParam sets parameter at given path to given value.\nreturns error if path not found or value cannot be set.", Args: []string{"path", "val"}, Returns: []string{"error"}}, {Name: "NonDefaultParams", Doc: "NonDefaultParams returns a listing of all parameters in the Projection that\nare not at their default values -- useful for setting param styles etc.", Returns: []string{"string"}}, {Name: "AllParams", Doc: "AllParams returns a listing of all parameters in the Projection", Returns: []string{"string"}}, {Name: "WriteWtsJSON", Doc: "WriteWtsJSON writes the weights from this pathway from the receiver-side perspective\nin a JSON text format.  We build in the indentation logic to make it much faster and\nmore efficient.", Args: []string{"w", "depth"}}, {Name: "ReadWtsJSON", Doc: "ReadWtsJSON reads the weights from this pathway from the receiver-side perspective\nin a JSON text format.  This is for a set of weights that were saved *for one path only*\nand is not used for the network-level ReadWtsJSON, which reads into a separate\nstructure -- see SetWts method.", Args: []string{"r"}, Returns: []string{"error"}}, {Name: "SetWts", Doc: "SetWts sets the weights for this pathway from weights.Path decoded values", Args: []string{"pw"}, Returns: []string{"error"}}, {Name: "Build", Doc: "Build constructs the full connectivity among the layers as specified in this pathway.", Returns: []string{"error"}}}})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.Paths", IDName: "paths", Doc: "Paths is a slice of pathways"})

var _ = types.AddType(&types.Type{Name: "github.com/emer/emergent/v2/emer.PathType", IDName: "path-type", Doc: "PathType is the type of the pathway (extensible for more specialized algorithms).\nClass parameter styles automatically key off of these types."})

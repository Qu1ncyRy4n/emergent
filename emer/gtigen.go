// Code generated by "goki generate ./..."; DO NOT EDIT.

package emer

import (
	"goki.dev/gti"
	"goki.dev/ordmap"
)

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/emer.Layer",
	ShortName:  "emer.Layer",
	IDName:     "layer",
	Doc:        "Layer defines the basic interface for neural network layers, used for managing the structural\nelements of a network, and for visualization, I/O, etc.\nInterfaces are automatically pointers -- think of this as a pointer to your specific layer\ntype, with a very basic interface for accessing general structural properties.  Nothing\nalgorithm-specific is implemented here -- all of that goes in your specific layer struct.",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/emer.Layers",
	ShortName:  "emer.Layers",
	IDName:     "layers",
	Doc:        "Layers is a slice of layers",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:      "github.com/emer/emergent/v2/emer.LayerType",
	ShortName: "emer.LayerType",
	IDName:    "layer-type",
	Doc:       "LayerType is the type of the layer: Input, Hidden, Target, Compare.\nClass parameter styles automatically key off of these types.\nSpecialized algorithms can extend this to other types, but these types encompass\nmost standard neural network models.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "enums", Directive: "enum", Args: []string{}},
	},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/emer.LayNames",
	ShortName:  "emer.LayNames",
	IDName:     "lay-names",
	Doc:        "LayNames is a list of layer names.\nHas convenience methods for adding, validating.",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/emer.NetParams",
	ShortName:  "emer.NetParams",
	IDName:     "net-params",
	Doc:        "NetParams handles standard parameters for a Network only\n(use econfig and a Config struct for other configuration params)\nAssumes a Set named \"Base\" has the base-level parameters, which are\nalways applied first, followed optionally by additional Set(s)\nthat can have different parameters to try.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Params", &gti.Field{Name: "Params", Type: "github.com/emer/emergent/v2/netparams.Sets", LocalType: "netparams.Sets", Doc: "full collection of param sets to use", Directives: gti.Directives{}, Tag: "view:\"no-inline\""}},
		{"ExtraSheets", &gti.Field{Name: "ExtraSheets", Type: "string", LocalType: "string", Doc: "optional additional sheets of parameters to apply after Base -- can use multiple names separated by spaces (don't put spaces in Sheet names!)", Directives: gti.Directives{}, Tag: ""}},
		{"Tag", &gti.Field{Name: "Tag", Type: "string", LocalType: "string", Doc: "optional additional tag to add to file names, logs to identify params / run config", Directives: gti.Directives{}, Tag: ""}},
		{"Network", &gti.Field{Name: "Network", Type: "github.com/emer/emergent/v2/emer.Network", LocalType: "Network", Doc: "the network to apply parameters to", Directives: gti.Directives{}, Tag: "view:\"-\""}},
		{"NetHypers", &gti.Field{Name: "NetHypers", Type: "github.com/emer/emergent/v2/params.Flex", LocalType: "params.Flex", Doc: "list of hyper parameters compiled from the network parameters, using the layers and projections from the network, so that the same styling logic as for regular parameters can be used", Directives: gti.Directives{}, Tag: "view:\"-\""}},
		{"SetMsg", &gti.Field{Name: "SetMsg", Type: "bool", LocalType: "bool", Doc: "print out messages for each parameter that is set", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/emer.LaySize",
	ShortName:  "emer.LaySize",
	IDName:     "lay-size",
	Doc:        "LaySize contains parameters for size of layers",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Y", &gti.Field{Name: "Y", Type: "int", LocalType: "int", Doc: "Y (vertical) size of layer -- in units for 2D, or number of pools (outer dimension) for 4D layer", Directives: gti.Directives{}, Tag: ""}},
		{"X", &gti.Field{Name: "X", Type: "int", LocalType: "int", Doc: "X (horizontal) size of layer -- in units for 2D, or number of pools (outer dimension) for 4D layer", Directives: gti.Directives{}, Tag: ""}},
		{"PoolY", &gti.Field{Name: "PoolY", Type: "int", LocalType: "int", Doc: "Y (vertical) size of each pool in units, only for 4D layers (inner dimension)", Directives: gti.Directives{}, Tag: ""}},
		{"PoolX", &gti.Field{Name: "PoolX", Type: "int", LocalType: "int", Doc: "Y (horizontal) size of each pool in units, only for 4D layers (inner dimension)", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/emer.NetSize",
	ShortName:  "emer.NetSize",
	IDName:     "net-size",
	Doc:        "NetSize is a network schema for holding a params for layer sizes.\nValues can be queried for getting sizes when configuring the network.\nUses params.Flex to support flexible parameter specification",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/emer.Network",
	ShortName:  "emer.Network",
	IDName:     "network",
	Doc:        "Network defines the basic interface for a neural network, used for managing the structural\nelements of a network, and for visualization, I/O, etc",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/emer.Params",
	ShortName:  "emer.Params",
	IDName:     "params",
	Doc:        "Params handles standard parameters for a Network and other objects.\nAssumes a Set named \"Base\" has the base-level parameters, which are\nalways applied first, followed optionally by additional Set(s)\nthat can have different parameters to try.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Params", &gti.Field{Name: "Params", Type: "github.com/emer/emergent/v2/params.Sets", LocalType: "params.Sets", Doc: "full collection of param sets to use", Directives: gti.Directives{}, Tag: "view:\"no-inline\""}},
		{"ExtraSets", &gti.Field{Name: "ExtraSets", Type: "string", LocalType: "string", Doc: "optional additional set(s) of parameters to apply after Base -- can use multiple names separated by spaces (don't put spaces in Set names!)", Directives: gti.Directives{}, Tag: ""}},
		{"Tag", &gti.Field{Name: "Tag", Type: "string", LocalType: "string", Doc: "optional additional tag to add to file names, logs to identify params / run config", Directives: gti.Directives{}, Tag: ""}},
		{"Objects", &gti.Field{Name: "Objects", Type: "map[string]any", LocalType: "map[string]any", Doc: "map of objects to apply parameters to -- the key is the name of the Sheet for each object, e.g.,", Directives: gti.Directives{}, Tag: "view:\"-\" Network\", \"Sim\" are typically used\""}},
		{"NetHypers", &gti.Field{Name: "NetHypers", Type: "github.com/emer/emergent/v2/params.Flex", LocalType: "params.Flex", Doc: "list of hyper parameters compiled from the network parameters, using the layers and projections from the network, so that the same styling logic as for regular parameters can be used", Directives: gti.Directives{}, Tag: "view:\"-\""}},
		{"SetMsg", &gti.Field{Name: "SetMsg", Type: "bool", LocalType: "bool", Doc: "print out messages for each parameter that is set", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/emer.Prjn",
	ShortName:  "emer.Prjn",
	IDName:     "prjn",
	Doc:        "Prjn defines the basic interface for a projection which connects two layers.\nName is set automatically to: SendLay().Name() + \"To\" + RecvLay().Name()",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/emer.Prjns",
	ShortName:  "emer.Prjns",
	IDName:     "prjns",
	Doc:        "Prjns is a slice of projections",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:      "github.com/emer/emergent/v2/emer.PrjnType",
	ShortName: "emer.PrjnType",
	IDName:    "prjn-type",
	Doc:       "PrjnType is the type of the projection (extensible for more specialized algorithms).\nClass parameter styles automatically key off of these types.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "enums", Directive: "enum", Args: []string{}},
	},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

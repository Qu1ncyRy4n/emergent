// Code generated by "goki generate ./..."; DO NOT EDIT.

package stepper

import (
	"goki.dev/gti"
	"goki.dev/ordmap"
)

var _ = gti.AddType(&gti.Type{
	Name:      "github.com/emer/emergent/v2/stepper.RunState",
	ShortName: "stepper.RunState",
	IDName:    "run-state",
	Doc:       "",
	Directives: gti.Directives{
		&gti.Directive{Tool: "enums", Directive: "enum", Args: []string{}},
	},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/stepper.StopCheckFn",
	ShortName:  "stepper.StopCheckFn",
	IDName:     "stop-check-fn",
	Doc:        "A StopCheckFn is a callback to check whether an arbitrary condition has been matched.\nIf a StopCheckFn returns true, the program is suspended with a RunState of Paused,\nand will remain so until the RunState changes to Stepping, Running, or Stopped.\nAs noted below for the PauseNotifyFn, the StopCheckFn is called with the Stepper's lock held.",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/stepper.PauseNotifyFn",
	ShortName:  "stepper.PauseNotifyFn",
	IDName:     "pause-notify-fn",
	Doc:        "A PauseNotifyFn is a callback that will be invoked if the program enters the Paused state.\nNOTE! The PauseNotifyFn is called with the Stepper's lock held, so it must not call any Stepper methods\nthat try to take the lock on entry, or a deadlock will result.",
	Directives: gti.Directives{},

	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})

var _ = gti.AddType(&gti.Type{
	Name:       "github.com/emer/emergent/v2/stepper.Stepper",
	ShortName:  "stepper.Stepper",
	IDName:     "stepper",
	Doc:        "The Stepper struct contains all of the state info for stepping a program, enabling step points.\nwhere the running application can be suspended with no loss of state.",
	Directives: gti.Directives{},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"RunState", &gti.Field{Name: "RunState", Type: "github.com/emer/emergent/v2/stepper.RunState", LocalType: "RunState", Doc: "current run state", Directives: gti.Directives{}, Tag: ""}},
		{"StepGrain", &gti.Field{Name: "StepGrain", Type: "int", LocalType: "int", Doc: "granularity of one step. No enum type here so clients can define their own", Directives: gti.Directives{}, Tag: ""}},
		{"StepsPer", &gti.Field{Name: "StepsPer", Type: "int", LocalType: "int", Doc: "number of steps to execute before returning", Directives: gti.Directives{}, Tag: ""}},
		{"PauseNotifyFn", &gti.Field{Name: "PauseNotifyFn", Type: "github.com/emer/emergent/v2/stepper.PauseNotifyFn", LocalType: "PauseNotifyFn", Doc: "function to deal with any changes on client side when paused after stepping", Directives: gti.Directives{}, Tag: "view:\"-\""}},
		{"StopCheckFn", &gti.Field{Name: "StopCheckFn", Type: "github.com/emer/emergent/v2/stepper.StopCheckFn", LocalType: "StopCheckFn", Doc: "function to test for special stopping conditions", Directives: gti.Directives{}, Tag: "view:\"-\""}},
		{"stateMut", &gti.Field{Name: "stateMut", Type: "sync.Mutex", LocalType: "sync.Mutex", Doc: "mutex for RunState", Directives: gti.Directives{}, Tag: "view:\"-\""}},
		{"stateChange", &gti.Field{Name: "stateChange", Type: "*sync.Cond", LocalType: "*sync.Cond", Doc: "state change condition variable", Directives: gti.Directives{}, Tag: "view:\"-\""}},
		{"stepsLeft", &gti.Field{Name: "stepsLeft", Type: "int", LocalType: "int", Doc: "number of steps yet to execute before returning", Directives: gti.Directives{}, Tag: "view:\"-\""}},
		{"waitTimer", &gti.Field{Name: "waitTimer", Type: "chan github.com/emer/emergent/v2/stepper.RunState", LocalType: "chan RunState", Doc: "watchdog timer channel", Directives: gti.Directives{}, Tag: ""}},
		{"initOnce", &gti.Field{Name: "initOnce", Type: "sync.Once", LocalType: "sync.Once", Doc: "this ensures that global initialization only happens once", Directives: gti.Directives{}, Tag: "view:\"-\""}},
	}),
	Embeds:  ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{}),
})
